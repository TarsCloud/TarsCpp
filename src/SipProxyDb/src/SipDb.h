// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.21.
// **********************************************************************

#ifndef __SIPDB_H_
#define __SIPDB_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace VoipApp
{
    enum OperationCategory
    {
        kOperationCategoryUnknown = -1,
        kOperationCategoryAdd,
        kOperationCategoryRemove,
        kOperationCategoryModify,
    };
    inline string etos(const OperationCategory & e)
    {
        switch(e)
        {
            case kOperationCategoryUnknown: return "kOperationCategoryUnknown";
            case kOperationCategoryAdd: return "kOperationCategoryAdd";
            case kOperationCategoryRemove: return "kOperationCategoryRemove";
            case kOperationCategoryModify: return "kOperationCategoryModify";
            default: return "";
        }
    }
    inline int stoe(const string & s, OperationCategory & e)
    {
        if(s == "kOperationCategoryUnknown")  { e=kOperationCategoryUnknown; return 0;}
        if(s == "kOperationCategoryAdd")  { e=kOperationCategoryAdd; return 0;}
        if(s == "kOperationCategoryRemove")  { e=kOperationCategoryRemove; return 0;}
        if(s == "kOperationCategoryModify")  { e=kOperationCategoryModify; return 0;}

        return -1;
    }

    enum SipAccountPropertyType
    {
        kSipAccountPropertyAccountId = 0,
        kSipAccountPropertyDomainName = 1,
        kSipAccountPropertyCoreNetId,
        kSipAccountPropertyPassword,
        kSipAccountPropertyAuthName,
        kSipAccountPropertyProxyIndex,
        kSipAccountPropertyJustalkId,
        kSipAccountPropertyInUse,
        kSipAccountPropertyProxyed,
        kSipAccountPropertyLogined,
        kSipAccountPropertySipProxyId,
        kSipAccountPropertySBCIp,
        kSipAccountPropertySBCPort,
        kSipAccountPropertyRegisterIp,
        kSipAccountPropertyRegisterPort,
    };
    inline string etos(const SipAccountPropertyType & e)
    {
        switch(e)
        {
            case kSipAccountPropertyAccountId: return "kSipAccountPropertyAccountId";
            case kSipAccountPropertyDomainName: return "kSipAccountPropertyDomainName";
            case kSipAccountPropertyCoreNetId: return "kSipAccountPropertyCoreNetId";
            case kSipAccountPropertyPassword: return "kSipAccountPropertyPassword";
            case kSipAccountPropertyAuthName: return "kSipAccountPropertyAuthName";
            case kSipAccountPropertyProxyIndex: return "kSipAccountPropertyProxyIndex";
            case kSipAccountPropertyJustalkId: return "kSipAccountPropertyJustalkId";
            case kSipAccountPropertyInUse: return "kSipAccountPropertyInUse";
            case kSipAccountPropertyProxyed: return "kSipAccountPropertyProxyed";
            case kSipAccountPropertyLogined: return "kSipAccountPropertyLogined";
            case kSipAccountPropertySipProxyId: return "kSipAccountPropertySipProxyId";
            case kSipAccountPropertySBCIp: return "kSipAccountPropertySBCIp";
            case kSipAccountPropertySBCPort: return "kSipAccountPropertySBCPort";
            case kSipAccountPropertyRegisterIp: return "kSipAccountPropertyRegisterIp";
            case kSipAccountPropertyRegisterPort: return "kSipAccountPropertyRegisterPort";
            default: return "";
        }
    }
    inline int stoe(const string & s, SipAccountPropertyType & e)
    {
        if(s == "kSipAccountPropertyAccountId")  { e=kSipAccountPropertyAccountId; return 0;}
        if(s == "kSipAccountPropertyDomainName")  { e=kSipAccountPropertyDomainName; return 0;}
        if(s == "kSipAccountPropertyCoreNetId")  { e=kSipAccountPropertyCoreNetId; return 0;}
        if(s == "kSipAccountPropertyPassword")  { e=kSipAccountPropertyPassword; return 0;}
        if(s == "kSipAccountPropertyAuthName")  { e=kSipAccountPropertyAuthName; return 0;}
        if(s == "kSipAccountPropertyProxyIndex")  { e=kSipAccountPropertyProxyIndex; return 0;}
        if(s == "kSipAccountPropertyJustalkId")  { e=kSipAccountPropertyJustalkId; return 0;}
        if(s == "kSipAccountPropertyInUse")  { e=kSipAccountPropertyInUse; return 0;}
        if(s == "kSipAccountPropertyProxyed")  { e=kSipAccountPropertyProxyed; return 0;}
        if(s == "kSipAccountPropertyLogined")  { e=kSipAccountPropertyLogined; return 0;}
        if(s == "kSipAccountPropertySipProxyId")  { e=kSipAccountPropertySipProxyId; return 0;}
        if(s == "kSipAccountPropertySBCIp")  { e=kSipAccountPropertySBCIp; return 0;}
        if(s == "kSipAccountPropertySBCPort")  { e=kSipAccountPropertySBCPort; return 0;}
        if(s == "kSipAccountPropertyRegisterIp")  { e=kSipAccountPropertyRegisterIp; return 0;}
        if(s == "kSipAccountPropertyRegisterPort")  { e=kSipAccountPropertyRegisterPort; return 0;}

        return -1;
    }

    struct SipRegInfoStruc : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipRegInfoStruc";
        }
        static string MD5()
        {
            return "5647c93769fc713e49da94877e533f8c";
        }
        SipRegInfoStruc()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            _sipUri = "";
            _sipAccount = "";
            _passWord = "";
            _authName = "";
            _sipProxyId = "";
            _lastHttpRegTime = 0;
            _lastRegTime = 0;
            _expires = 0;
            _registarIp = "";
            _registarPort = 0;
            _clientIp = "";
            _clientPort = 0;
            _callId = "";
            _fromTag = "";
            _toTag = "";
            _CSeqNum = 0;
            _viaBranch = "";
            _event = 0;
            _eventId = "";
            _realm = "";
            _nonce = "";
            _Nc = 0;
            _opaque = "";
            _response = "";
            _qopExist = false;
            _qopValue = 0;
            _Cnonce = "";
            _reqUserInfo = "";
            _reqUrl = "";
            _coreNetId = "";
            _SBCIp = "";
            _SBCPort = 0;
            _algo = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(_sipUri, 0);
            _os.write(_sipAccount, 1);
            _os.write(_passWord, 2);
            _os.write(_authName, 3);
            _os.write(_sipProxyId, 4);
            _os.write(_lastHttpRegTime, 5);
            _os.write(_lastRegTime, 6);
            _os.write(_expires, 7);
            _os.write(_registarIp, 8);
            _os.write(_registarPort, 9);
            _os.write(_clientIp, 10);
            _os.write(_clientPort, 11);
            _os.write(_callId, 12);
            _os.write(_fromTag, 13);
            _os.write(_toTag, 14);
            _os.write(_CSeqNum, 15);
            _os.write(_viaBranch, 16);
            _os.write(_event, 17);
            _os.write(_eventId, 18);
            _os.write(_realm, 19);
            _os.write(_nonce, 20);
            _os.write(_Nc, 21);
            _os.write(_opaque, 22);
            _os.write(_response, 23);
            _os.write(_qopExist, 24);
            _os.write(_qopValue, 25);
            _os.write(_Cnonce, 26);
            _os.write(_reqUserInfo, 27);
            _os.write(_reqUrl, 28);
            _os.write(_coreNetId, 29);
            _os.write(_SBCIp, 30);
            _os.write(_SBCPort, 31);
            _os.write(_algo, 32);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(_sipUri, 0, true);
            _is.read(_sipAccount, 1, true);
            _is.read(_passWord, 2, true);
            _is.read(_authName, 3, true);
            _is.read(_sipProxyId, 4, true);
            _is.read(_lastHttpRegTime, 5, true);
            _is.read(_lastRegTime, 6, true);
            _is.read(_expires, 7, true);
            _is.read(_registarIp, 8, true);
            _is.read(_registarPort, 9, true);
            _is.read(_clientIp, 10, true);
            _is.read(_clientPort, 11, true);
            _is.read(_callId, 12, true);
            _is.read(_fromTag, 13, true);
            _is.read(_toTag, 14, true);
            _is.read(_CSeqNum, 15, true);
            _is.read(_viaBranch, 16, true);
            _is.read(_event, 17, true);
            _is.read(_eventId, 18, true);
            _is.read(_realm, 19, true);
            _is.read(_nonce, 20, true);
            _is.read(_Nc, 21, true);
            _is.read(_opaque, 22, true);
            _is.read(_response, 23, true);
            _is.read(_qopExist, 24, true);
            _is.read(_qopValue, 25, true);
            _is.read(_Cnonce, 26, true);
            _is.read(_reqUserInfo, 27, true);
            _is.read(_reqUrl, 28, true);
            _is.read(_coreNetId, 29, true);
            _is.read(_SBCIp, 30, true);
            _is.read(_SBCPort, 31, true);
            _is.read(_algo, 32, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["_sipUri"] = tars::JsonOutput::writeJson(_sipUri);
            p->value["_sipAccount"] = tars::JsonOutput::writeJson(_sipAccount);
            p->value["_passWord"] = tars::JsonOutput::writeJson(_passWord);
            p->value["_authName"] = tars::JsonOutput::writeJson(_authName);
            p->value["_sipProxyId"] = tars::JsonOutput::writeJson(_sipProxyId);
            p->value["_lastHttpRegTime"] = tars::JsonOutput::writeJson(_lastHttpRegTime);
            p->value["_lastRegTime"] = tars::JsonOutput::writeJson(_lastRegTime);
            p->value["_expires"] = tars::JsonOutput::writeJson(_expires);
            p->value["_registarIp"] = tars::JsonOutput::writeJson(_registarIp);
            p->value["_registarPort"] = tars::JsonOutput::writeJson(_registarPort);
            p->value["_clientIp"] = tars::JsonOutput::writeJson(_clientIp);
            p->value["_clientPort"] = tars::JsonOutput::writeJson(_clientPort);
            p->value["_callId"] = tars::JsonOutput::writeJson(_callId);
            p->value["_fromTag"] = tars::JsonOutput::writeJson(_fromTag);
            p->value["_toTag"] = tars::JsonOutput::writeJson(_toTag);
            p->value["_CSeqNum"] = tars::JsonOutput::writeJson(_CSeqNum);
            p->value["_viaBranch"] = tars::JsonOutput::writeJson(_viaBranch);
            p->value["_event"] = tars::JsonOutput::writeJson(_event);
            p->value["_eventId"] = tars::JsonOutput::writeJson(_eventId);
            p->value["_realm"] = tars::JsonOutput::writeJson(_realm);
            p->value["_nonce"] = tars::JsonOutput::writeJson(_nonce);
            p->value["_Nc"] = tars::JsonOutput::writeJson(_Nc);
            p->value["_opaque"] = tars::JsonOutput::writeJson(_opaque);
            p->value["_response"] = tars::JsonOutput::writeJson(_response);
            p->value["_qopExist"] = tars::JsonOutput::writeJson(_qopExist);
            p->value["_qopValue"] = tars::JsonOutput::writeJson(_qopValue);
            p->value["_Cnonce"] = tars::JsonOutput::writeJson(_Cnonce);
            p->value["_reqUserInfo"] = tars::JsonOutput::writeJson(_reqUserInfo);
            p->value["_reqUrl"] = tars::JsonOutput::writeJson(_reqUrl);
            p->value["_coreNetId"] = tars::JsonOutput::writeJson(_coreNetId);
            p->value["_SBCIp"] = tars::JsonOutput::writeJson(_SBCIp);
            p->value["_SBCPort"] = tars::JsonOutput::writeJson(_SBCPort);
            p->value["_algo"] = tars::JsonOutput::writeJson(_algo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(_sipUri,pObj->value["_sipUri"], true);
            tars::JsonInput::readJson(_sipAccount,pObj->value["_sipAccount"], true);
            tars::JsonInput::readJson(_passWord,pObj->value["_passWord"], true);
            tars::JsonInput::readJson(_authName,pObj->value["_authName"], true);
            tars::JsonInput::readJson(_sipProxyId,pObj->value["_sipProxyId"], true);
            tars::JsonInput::readJson(_lastHttpRegTime,pObj->value["_lastHttpRegTime"], true);
            tars::JsonInput::readJson(_lastRegTime,pObj->value["_lastRegTime"], true);
            tars::JsonInput::readJson(_expires,pObj->value["_expires"], true);
            tars::JsonInput::readJson(_registarIp,pObj->value["_registarIp"], true);
            tars::JsonInput::readJson(_registarPort,pObj->value["_registarPort"], true);
            tars::JsonInput::readJson(_clientIp,pObj->value["_clientIp"], true);
            tars::JsonInput::readJson(_clientPort,pObj->value["_clientPort"], true);
            tars::JsonInput::readJson(_callId,pObj->value["_callId"], true);
            tars::JsonInput::readJson(_fromTag,pObj->value["_fromTag"], true);
            tars::JsonInput::readJson(_toTag,pObj->value["_toTag"], true);
            tars::JsonInput::readJson(_CSeqNum,pObj->value["_CSeqNum"], true);
            tars::JsonInput::readJson(_viaBranch,pObj->value["_viaBranch"], true);
            tars::JsonInput::readJson(_event,pObj->value["_event"], true);
            tars::JsonInput::readJson(_eventId,pObj->value["_eventId"], true);
            tars::JsonInput::readJson(_realm,pObj->value["_realm"], true);
            tars::JsonInput::readJson(_nonce,pObj->value["_nonce"], true);
            tars::JsonInput::readJson(_Nc,pObj->value["_Nc"], true);
            tars::JsonInput::readJson(_opaque,pObj->value["_opaque"], true);
            tars::JsonInput::readJson(_response,pObj->value["_response"], true);
            tars::JsonInput::readJson(_qopExist,pObj->value["_qopExist"], true);
            tars::JsonInput::readJson(_qopValue,pObj->value["_qopValue"], true);
            tars::JsonInput::readJson(_Cnonce,pObj->value["_Cnonce"], true);
            tars::JsonInput::readJson(_reqUserInfo,pObj->value["_reqUserInfo"], true);
            tars::JsonInput::readJson(_reqUrl,pObj->value["_reqUrl"], true);
            tars::JsonInput::readJson(_coreNetId,pObj->value["_coreNetId"], true);
            tars::JsonInput::readJson(_SBCIp,pObj->value["_SBCIp"], true);
            tars::JsonInput::readJson(_SBCPort,pObj->value["_SBCPort"], true);
            tars::JsonInput::readJson(_algo,pObj->value["_algo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(_sipUri,"_sipUri");
            _ds.display(_sipAccount,"_sipAccount");
            _ds.display(_passWord,"_passWord");
            _ds.display(_authName,"_authName");
            _ds.display(_sipProxyId,"_sipProxyId");
            _ds.display(_lastHttpRegTime,"_lastHttpRegTime");
            _ds.display(_lastRegTime,"_lastRegTime");
            _ds.display(_expires,"_expires");
            _ds.display(_registarIp,"_registarIp");
            _ds.display(_registarPort,"_registarPort");
            _ds.display(_clientIp,"_clientIp");
            _ds.display(_clientPort,"_clientPort");
            _ds.display(_callId,"_callId");
            _ds.display(_fromTag,"_fromTag");
            _ds.display(_toTag,"_toTag");
            _ds.display(_CSeqNum,"_CSeqNum");
            _ds.display(_viaBranch,"_viaBranch");
            _ds.display(_event,"_event");
            _ds.display(_eventId,"_eventId");
            _ds.display(_realm,"_realm");
            _ds.display(_nonce,"_nonce");
            _ds.display(_Nc,"_Nc");
            _ds.display(_opaque,"_opaque");
            _ds.display(_response,"_response");
            _ds.display(_qopExist,"_qopExist");
            _ds.display(_qopValue,"_qopValue");
            _ds.display(_Cnonce,"_Cnonce");
            _ds.display(_reqUserInfo,"_reqUserInfo");
            _ds.display(_reqUrl,"_reqUrl");
            _ds.display(_coreNetId,"_coreNetId");
            _ds.display(_SBCIp,"_SBCIp");
            _ds.display(_SBCPort,"_SBCPort");
            _ds.display(_algo,"_algo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(_sipUri, true);
            _ds.displaySimple(_sipAccount, true);
            _ds.displaySimple(_passWord, true);
            _ds.displaySimple(_authName, true);
            _ds.displaySimple(_sipProxyId, true);
            _ds.displaySimple(_lastHttpRegTime, true);
            _ds.displaySimple(_lastRegTime, true);
            _ds.displaySimple(_expires, true);
            _ds.displaySimple(_registarIp, true);
            _ds.displaySimple(_registarPort, true);
            _ds.displaySimple(_clientIp, true);
            _ds.displaySimple(_clientPort, true);
            _ds.displaySimple(_callId, true);
            _ds.displaySimple(_fromTag, true);
            _ds.displaySimple(_toTag, true);
            _ds.displaySimple(_CSeqNum, true);
            _ds.displaySimple(_viaBranch, true);
            _ds.displaySimple(_event, true);
            _ds.displaySimple(_eventId, true);
            _ds.displaySimple(_realm, true);
            _ds.displaySimple(_nonce, true);
            _ds.displaySimple(_Nc, true);
            _ds.displaySimple(_opaque, true);
            _ds.displaySimple(_response, true);
            _ds.displaySimple(_qopExist, true);
            _ds.displaySimple(_qopValue, true);
            _ds.displaySimple(_Cnonce, true);
            _ds.displaySimple(_reqUserInfo, true);
            _ds.displaySimple(_reqUrl, true);
            _ds.displaySimple(_coreNetId, true);
            _ds.displaySimple(_SBCIp, true);
            _ds.displaySimple(_SBCPort, true);
            _ds.displaySimple(_algo, false);
            return _os;
        }
    public:
        std::string _sipUri;
        std::string _sipAccount;
        std::string _passWord;
        std::string _authName;
        std::string _sipProxyId;
        tars::Int64 _lastHttpRegTime;
        tars::Int64 _lastRegTime;
        tars::Int32 _expires;
        std::string _registarIp;
        tars::Int32 _registarPort;
        std::string _clientIp;
        tars::Int32 _clientPort;
        std::string _callId;
        std::string _fromTag;
        std::string _toTag;
        tars::Int32 _CSeqNum;
        std::string _viaBranch;
        tars::Int32 _event;
        std::string _eventId;
        std::string _realm;
        std::string _nonce;
        tars::Int32 _Nc;
        std::string _opaque;
        std::string _response;
        tars::Bool _qopExist;
        tars::Int32 _qopValue;
        std::string _Cnonce;
        std::string _reqUserInfo;
        std::string _reqUrl;
        std::string _coreNetId;
        std::string _SBCIp;
        tars::Int32 _SBCPort;
        tars::Int32 _algo;
    };
    inline bool operator==(const SipRegInfoStruc&l, const SipRegInfoStruc&r)
    {
        return l._sipUri == r._sipUri && l._sipAccount == r._sipAccount && l._passWord == r._passWord && l._authName == r._authName && l._sipProxyId == r._sipProxyId && l._lastHttpRegTime == r._lastHttpRegTime && l._lastRegTime == r._lastRegTime && l._expires == r._expires && l._registarIp == r._registarIp && l._registarPort == r._registarPort && l._clientIp == r._clientIp && l._clientPort == r._clientPort && l._callId == r._callId && l._fromTag == r._fromTag && l._toTag == r._toTag && l._CSeqNum == r._CSeqNum && l._viaBranch == r._viaBranch && l._event == r._event && l._eventId == r._eventId && l._realm == r._realm && l._nonce == r._nonce && l._Nc == r._Nc && l._opaque == r._opaque && l._response == r._response && l._qopExist == r._qopExist && l._qopValue == r._qopValue && l._Cnonce == r._Cnonce && l._reqUserInfo == r._reqUserInfo && l._reqUrl == r._reqUrl && l._coreNetId == r._coreNetId && l._SBCIp == r._SBCIp && l._SBCPort == r._SBCPort && l._algo == r._algo;
    }
    inline bool operator!=(const SipRegInfoStruc&l, const SipRegInfoStruc&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipRegInfoStruc&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipRegInfoStruc&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RegisterItemQuery : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.RegisterItemQuery";
        }
        static string MD5()
        {
            return "72dd4f78019e42299663957ddab15321";
        }
        RegisterItemQuery()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_sipUri = "";
            m_strClientId = "";
            m_strDomainName = "";
            m_strPassWord = "";
            m_strAuthName = "";
            m_strClientIp = "";
            m_iPort = 0;
            m_bLogined = false;
            m_bPermitedToProxy = false;
            m_strCoreNetId = "";
            m_strSBCIp = "";
            m_iSBCport = 0;
            m_strRegistarIp = "";
            m_iRegistarPort = 0;
            m_iFailedRegTimes = 0;
            m_lLastFailedRegTime = 0;
            m_lLoginedTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_sipUri, 0);
            _os.write(m_strClientId, 1);
            _os.write(m_strDomainName, 2);
            _os.write(m_strPassWord, 3);
            _os.write(m_strAuthName, 4);
            _os.write(m_strClientIp, 5);
            _os.write(m_iPort, 6);
            _os.write(m_bLogined, 7);
            _os.write(m_bPermitedToProxy, 8);
            _os.write(m_strCoreNetId, 9);
            _os.write(m_strSBCIp, 10);
            _os.write(m_iSBCport, 11);
            _os.write(m_strRegistarIp, 12);
            _os.write(m_iRegistarPort, 13);
            _os.write(m_iFailedRegTimes, 14);
            _os.write(m_lLastFailedRegTime, 15);
            _os.write(m_lLoginedTime, 16);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_sipUri, 0, true);
            _is.read(m_strClientId, 1, true);
            _is.read(m_strDomainName, 2, true);
            _is.read(m_strPassWord, 3, true);
            _is.read(m_strAuthName, 4, true);
            _is.read(m_strClientIp, 5, true);
            _is.read(m_iPort, 6, true);
            _is.read(m_bLogined, 7, true);
            _is.read(m_bPermitedToProxy, 8, true);
            _is.read(m_strCoreNetId, 9, true);
            _is.read(m_strSBCIp, 10, true);
            _is.read(m_iSBCport, 11, true);
            _is.read(m_strRegistarIp, 12, true);
            _is.read(m_iRegistarPort, 13, true);
            _is.read(m_iFailedRegTimes, 14, true);
            _is.read(m_lLastFailedRegTime, 15, true);
            _is.read(m_lLoginedTime, 16, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_sipUri"] = tars::JsonOutput::writeJson(m_sipUri);
            p->value["m_strClientId"] = tars::JsonOutput::writeJson(m_strClientId);
            p->value["m_strDomainName"] = tars::JsonOutput::writeJson(m_strDomainName);
            p->value["m_strPassWord"] = tars::JsonOutput::writeJson(m_strPassWord);
            p->value["m_strAuthName"] = tars::JsonOutput::writeJson(m_strAuthName);
            p->value["m_strClientIp"] = tars::JsonOutput::writeJson(m_strClientIp);
            p->value["m_iPort"] = tars::JsonOutput::writeJson(m_iPort);
            p->value["m_bLogined"] = tars::JsonOutput::writeJson(m_bLogined);
            p->value["m_bPermitedToProxy"] = tars::JsonOutput::writeJson(m_bPermitedToProxy);
            p->value["m_strCoreNetId"] = tars::JsonOutput::writeJson(m_strCoreNetId);
            p->value["m_strSBCIp"] = tars::JsonOutput::writeJson(m_strSBCIp);
            p->value["m_iSBCport"] = tars::JsonOutput::writeJson(m_iSBCport);
            p->value["m_strRegistarIp"] = tars::JsonOutput::writeJson(m_strRegistarIp);
            p->value["m_iRegistarPort"] = tars::JsonOutput::writeJson(m_iRegistarPort);
            p->value["m_iFailedRegTimes"] = tars::JsonOutput::writeJson(m_iFailedRegTimes);
            p->value["m_lLastFailedRegTime"] = tars::JsonOutput::writeJson(m_lLastFailedRegTime);
            p->value["m_lLoginedTime"] = tars::JsonOutput::writeJson(m_lLoginedTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_sipUri,pObj->value["m_sipUri"], true);
            tars::JsonInput::readJson(m_strClientId,pObj->value["m_strClientId"], true);
            tars::JsonInput::readJson(m_strDomainName,pObj->value["m_strDomainName"], true);
            tars::JsonInput::readJson(m_strPassWord,pObj->value["m_strPassWord"], true);
            tars::JsonInput::readJson(m_strAuthName,pObj->value["m_strAuthName"], true);
            tars::JsonInput::readJson(m_strClientIp,pObj->value["m_strClientIp"], true);
            tars::JsonInput::readJson(m_iPort,pObj->value["m_iPort"], true);
            tars::JsonInput::readJson(m_bLogined,pObj->value["m_bLogined"], true);
            tars::JsonInput::readJson(m_bPermitedToProxy,pObj->value["m_bPermitedToProxy"], true);
            tars::JsonInput::readJson(m_strCoreNetId,pObj->value["m_strCoreNetId"], true);
            tars::JsonInput::readJson(m_strSBCIp,pObj->value["m_strSBCIp"], true);
            tars::JsonInput::readJson(m_iSBCport,pObj->value["m_iSBCport"], true);
            tars::JsonInput::readJson(m_strRegistarIp,pObj->value["m_strRegistarIp"], true);
            tars::JsonInput::readJson(m_iRegistarPort,pObj->value["m_iRegistarPort"], true);
            tars::JsonInput::readJson(m_iFailedRegTimes,pObj->value["m_iFailedRegTimes"], true);
            tars::JsonInput::readJson(m_lLastFailedRegTime,pObj->value["m_lLastFailedRegTime"], true);
            tars::JsonInput::readJson(m_lLoginedTime,pObj->value["m_lLoginedTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_sipUri,"m_sipUri");
            _ds.display(m_strClientId,"m_strClientId");
            _ds.display(m_strDomainName,"m_strDomainName");
            _ds.display(m_strPassWord,"m_strPassWord");
            _ds.display(m_strAuthName,"m_strAuthName");
            _ds.display(m_strClientIp,"m_strClientIp");
            _ds.display(m_iPort,"m_iPort");
            _ds.display(m_bLogined,"m_bLogined");
            _ds.display(m_bPermitedToProxy,"m_bPermitedToProxy");
            _ds.display(m_strCoreNetId,"m_strCoreNetId");
            _ds.display(m_strSBCIp,"m_strSBCIp");
            _ds.display(m_iSBCport,"m_iSBCport");
            _ds.display(m_strRegistarIp,"m_strRegistarIp");
            _ds.display(m_iRegistarPort,"m_iRegistarPort");
            _ds.display(m_iFailedRegTimes,"m_iFailedRegTimes");
            _ds.display(m_lLastFailedRegTime,"m_lLastFailedRegTime");
            _ds.display(m_lLoginedTime,"m_lLoginedTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_sipUri, true);
            _ds.displaySimple(m_strClientId, true);
            _ds.displaySimple(m_strDomainName, true);
            _ds.displaySimple(m_strPassWord, true);
            _ds.displaySimple(m_strAuthName, true);
            _ds.displaySimple(m_strClientIp, true);
            _ds.displaySimple(m_iPort, true);
            _ds.displaySimple(m_bLogined, true);
            _ds.displaySimple(m_bPermitedToProxy, true);
            _ds.displaySimple(m_strCoreNetId, true);
            _ds.displaySimple(m_strSBCIp, true);
            _ds.displaySimple(m_iSBCport, true);
            _ds.displaySimple(m_strRegistarIp, true);
            _ds.displaySimple(m_iRegistarPort, true);
            _ds.displaySimple(m_iFailedRegTimes, true);
            _ds.displaySimple(m_lLastFailedRegTime, true);
            _ds.displaySimple(m_lLoginedTime, false);
            return _os;
        }
    public:
        std::string m_sipUri;
        std::string m_strClientId;
        std::string m_strDomainName;
        std::string m_strPassWord;
        std::string m_strAuthName;
        std::string m_strClientIp;
        tars::Int32 m_iPort;
        tars::Bool m_bLogined;
        tars::Bool m_bPermitedToProxy;
        std::string m_strCoreNetId;
        std::string m_strSBCIp;
        tars::Int32 m_iSBCport;
        std::string m_strRegistarIp;
        tars::Int32 m_iRegistarPort;
        tars::Int32 m_iFailedRegTimes;
        tars::Int64 m_lLastFailedRegTime;
        tars::Int64 m_lLoginedTime;
    };
    inline bool operator==(const RegisterItemQuery&l, const RegisterItemQuery&r)
    {
        return l.m_sipUri == r.m_sipUri && l.m_strClientId == r.m_strClientId && l.m_strDomainName == r.m_strDomainName && l.m_strPassWord == r.m_strPassWord && l.m_strAuthName == r.m_strAuthName && l.m_strClientIp == r.m_strClientIp && l.m_iPort == r.m_iPort && l.m_bLogined == r.m_bLogined && l.m_bPermitedToProxy == r.m_bPermitedToProxy && l.m_strCoreNetId == r.m_strCoreNetId && l.m_strSBCIp == r.m_strSBCIp && l.m_iSBCport == r.m_iSBCport && l.m_strRegistarIp == r.m_strRegistarIp && l.m_iRegistarPort == r.m_iRegistarPort && l.m_iFailedRegTimes == r.m_iFailedRegTimes && l.m_lLastFailedRegTime == r.m_lLastFailedRegTime && l.m_lLoginedTime == r.m_lLoginedTime;
    }
    inline bool operator!=(const RegisterItemQuery&l, const RegisterItemQuery&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RegisterItemQuery&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RegisterItemQuery&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DomainAccessedConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.DomainAccessedConfig";
        }
        static string MD5()
        {
            return "165870c924814bb8524c0eded0655405";
        }
        DomainAccessedConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_strDomainIdAppId = "";
            m_strDomainName = "";
            m_strAppKey = "";
            m_strRelationType = "";
            m_bAuthorited = false;
            m_bCharged = false;
            m_bRegWhenLogined = false;
            m_bForbitFailedReReg = false;
            m_iMaxFailedReRegTimes = 0;
            m_bAllowReRegInterval = false;
            m_iFailedReRegInterval = 0;
            m_bISBCAccessed = false;
            m_sipBindType = 0;
            m_strCoreNetIdName = "";
            m_strCalleePrefix = "";
            m_iCalleePrefixPriority = 0;
            m_strConfAccoutPrefix = "";
            m_strSBCIp = "";
            m_iSBCPort = 0;
            m_strRegistarIp = "";
            m_iRegistarPort = 0;
            m_fromSipAddrType = 0;
            m_toSipAddrType = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_strDomainIdAppId, 0);
            _os.write(m_strDomainName, 1);
            _os.write(m_strAppKey, 2);
            _os.write(m_strRelationType, 3);
            _os.write(m_bAuthorited, 4);
            _os.write(m_bCharged, 5);
            _os.write(m_bRegWhenLogined, 6);
            _os.write(m_bForbitFailedReReg, 7);
            _os.write(m_iMaxFailedReRegTimes, 8);
            _os.write(m_bAllowReRegInterval, 9);
            _os.write(m_iFailedReRegInterval, 10);
            _os.write(m_bISBCAccessed, 11);
            _os.write(m_sipBindType, 12);
            _os.write(m_strCoreNetIdName, 13);
            _os.write(m_strCalleePrefix, 14);
            _os.write(m_iCalleePrefixPriority, 15);
            _os.write(m_strConfAccoutPrefix, 16);
            _os.write(m_strSBCIp, 17);
            _os.write(m_iSBCPort, 18);
            _os.write(m_strRegistarIp, 19);
            _os.write(m_iRegistarPort, 20);
            if (m_fromSipAddrType != 0)
            {
                _os.write(m_fromSipAddrType, 21);
            }
            if (m_toSipAddrType != 0)
            {
                _os.write(m_toSipAddrType, 22);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_strDomainIdAppId, 0, true);
            _is.read(m_strDomainName, 1, true);
            _is.read(m_strAppKey, 2, true);
            _is.read(m_strRelationType, 3, true);
            _is.read(m_bAuthorited, 4, true);
            _is.read(m_bCharged, 5, true);
            _is.read(m_bRegWhenLogined, 6, true);
            _is.read(m_bForbitFailedReReg, 7, true);
            _is.read(m_iMaxFailedReRegTimes, 8, true);
            _is.read(m_bAllowReRegInterval, 9, true);
            _is.read(m_iFailedReRegInterval, 10, true);
            _is.read(m_bISBCAccessed, 11, true);
            _is.read(m_sipBindType, 12, true);
            _is.read(m_strCoreNetIdName, 13, true);
            _is.read(m_strCalleePrefix, 14, true);
            _is.read(m_iCalleePrefixPriority, 15, true);
            _is.read(m_strConfAccoutPrefix, 16, true);
            _is.read(m_strSBCIp, 17, true);
            _is.read(m_iSBCPort, 18, true);
            _is.read(m_strRegistarIp, 19, true);
            _is.read(m_iRegistarPort, 20, true);
            _is.read(m_fromSipAddrType, 21, false);
            _is.read(m_toSipAddrType, 22, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_strDomainIdAppId"] = tars::JsonOutput::writeJson(m_strDomainIdAppId);
            p->value["m_strDomainName"] = tars::JsonOutput::writeJson(m_strDomainName);
            p->value["m_strAppKey"] = tars::JsonOutput::writeJson(m_strAppKey);
            p->value["m_strRelationType"] = tars::JsonOutput::writeJson(m_strRelationType);
            p->value["m_bAuthorited"] = tars::JsonOutput::writeJson(m_bAuthorited);
            p->value["m_bCharged"] = tars::JsonOutput::writeJson(m_bCharged);
            p->value["m_bRegWhenLogined"] = tars::JsonOutput::writeJson(m_bRegWhenLogined);
            p->value["m_bForbitFailedReReg"] = tars::JsonOutput::writeJson(m_bForbitFailedReReg);
            p->value["m_iMaxFailedReRegTimes"] = tars::JsonOutput::writeJson(m_iMaxFailedReRegTimes);
            p->value["m_bAllowReRegInterval"] = tars::JsonOutput::writeJson(m_bAllowReRegInterval);
            p->value["m_iFailedReRegInterval"] = tars::JsonOutput::writeJson(m_iFailedReRegInterval);
            p->value["m_bISBCAccessed"] = tars::JsonOutput::writeJson(m_bISBCAccessed);
            p->value["m_sipBindType"] = tars::JsonOutput::writeJson(m_sipBindType);
            p->value["m_strCoreNetIdName"] = tars::JsonOutput::writeJson(m_strCoreNetIdName);
            p->value["m_strCalleePrefix"] = tars::JsonOutput::writeJson(m_strCalleePrefix);
            p->value["m_iCalleePrefixPriority"] = tars::JsonOutput::writeJson(m_iCalleePrefixPriority);
            p->value["m_strConfAccoutPrefix"] = tars::JsonOutput::writeJson(m_strConfAccoutPrefix);
            p->value["m_strSBCIp"] = tars::JsonOutput::writeJson(m_strSBCIp);
            p->value["m_iSBCPort"] = tars::JsonOutput::writeJson(m_iSBCPort);
            p->value["m_strRegistarIp"] = tars::JsonOutput::writeJson(m_strRegistarIp);
            p->value["m_iRegistarPort"] = tars::JsonOutput::writeJson(m_iRegistarPort);
            p->value["m_fromSipAddrType"] = tars::JsonOutput::writeJson(m_fromSipAddrType);
            p->value["m_toSipAddrType"] = tars::JsonOutput::writeJson(m_toSipAddrType);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_strDomainIdAppId,pObj->value["m_strDomainIdAppId"], true);
            tars::JsonInput::readJson(m_strDomainName,pObj->value["m_strDomainName"], true);
            tars::JsonInput::readJson(m_strAppKey,pObj->value["m_strAppKey"], true);
            tars::JsonInput::readJson(m_strRelationType,pObj->value["m_strRelationType"], true);
            tars::JsonInput::readJson(m_bAuthorited,pObj->value["m_bAuthorited"], true);
            tars::JsonInput::readJson(m_bCharged,pObj->value["m_bCharged"], true);
            tars::JsonInput::readJson(m_bRegWhenLogined,pObj->value["m_bRegWhenLogined"], true);
            tars::JsonInput::readJson(m_bForbitFailedReReg,pObj->value["m_bForbitFailedReReg"], true);
            tars::JsonInput::readJson(m_iMaxFailedReRegTimes,pObj->value["m_iMaxFailedReRegTimes"], true);
            tars::JsonInput::readJson(m_bAllowReRegInterval,pObj->value["m_bAllowReRegInterval"], true);
            tars::JsonInput::readJson(m_iFailedReRegInterval,pObj->value["m_iFailedReRegInterval"], true);
            tars::JsonInput::readJson(m_bISBCAccessed,pObj->value["m_bISBCAccessed"], true);
            tars::JsonInput::readJson(m_sipBindType,pObj->value["m_sipBindType"], true);
            tars::JsonInput::readJson(m_strCoreNetIdName,pObj->value["m_strCoreNetIdName"], true);
            tars::JsonInput::readJson(m_strCalleePrefix,pObj->value["m_strCalleePrefix"], true);
            tars::JsonInput::readJson(m_iCalleePrefixPriority,pObj->value["m_iCalleePrefixPriority"], true);
            tars::JsonInput::readJson(m_strConfAccoutPrefix,pObj->value["m_strConfAccoutPrefix"], true);
            tars::JsonInput::readJson(m_strSBCIp,pObj->value["m_strSBCIp"], true);
            tars::JsonInput::readJson(m_iSBCPort,pObj->value["m_iSBCPort"], true);
            tars::JsonInput::readJson(m_strRegistarIp,pObj->value["m_strRegistarIp"], true);
            tars::JsonInput::readJson(m_iRegistarPort,pObj->value["m_iRegistarPort"], true);
            tars::JsonInput::readJson(m_fromSipAddrType,pObj->value["m_fromSipAddrType"], false);
            tars::JsonInput::readJson(m_toSipAddrType,pObj->value["m_toSipAddrType"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_strDomainIdAppId,"m_strDomainIdAppId");
            _ds.display(m_strDomainName,"m_strDomainName");
            _ds.display(m_strAppKey,"m_strAppKey");
            _ds.display(m_strRelationType,"m_strRelationType");
            _ds.display(m_bAuthorited,"m_bAuthorited");
            _ds.display(m_bCharged,"m_bCharged");
            _ds.display(m_bRegWhenLogined,"m_bRegWhenLogined");
            _ds.display(m_bForbitFailedReReg,"m_bForbitFailedReReg");
            _ds.display(m_iMaxFailedReRegTimes,"m_iMaxFailedReRegTimes");
            _ds.display(m_bAllowReRegInterval,"m_bAllowReRegInterval");
            _ds.display(m_iFailedReRegInterval,"m_iFailedReRegInterval");
            _ds.display(m_bISBCAccessed,"m_bISBCAccessed");
            _ds.display(m_sipBindType,"m_sipBindType");
            _ds.display(m_strCoreNetIdName,"m_strCoreNetIdName");
            _ds.display(m_strCalleePrefix,"m_strCalleePrefix");
            _ds.display(m_iCalleePrefixPriority,"m_iCalleePrefixPriority");
            _ds.display(m_strConfAccoutPrefix,"m_strConfAccoutPrefix");
            _ds.display(m_strSBCIp,"m_strSBCIp");
            _ds.display(m_iSBCPort,"m_iSBCPort");
            _ds.display(m_strRegistarIp,"m_strRegistarIp");
            _ds.display(m_iRegistarPort,"m_iRegistarPort");
            _ds.display(m_fromSipAddrType,"m_fromSipAddrType");
            _ds.display(m_toSipAddrType,"m_toSipAddrType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_strDomainIdAppId, true);
            _ds.displaySimple(m_strDomainName, true);
            _ds.displaySimple(m_strAppKey, true);
            _ds.displaySimple(m_strRelationType, true);
            _ds.displaySimple(m_bAuthorited, true);
            _ds.displaySimple(m_bCharged, true);
            _ds.displaySimple(m_bRegWhenLogined, true);
            _ds.displaySimple(m_bForbitFailedReReg, true);
            _ds.displaySimple(m_iMaxFailedReRegTimes, true);
            _ds.displaySimple(m_bAllowReRegInterval, true);
            _ds.displaySimple(m_iFailedReRegInterval, true);
            _ds.displaySimple(m_bISBCAccessed, true);
            _ds.displaySimple(m_sipBindType, true);
            _ds.displaySimple(m_strCoreNetIdName, true);
            _ds.displaySimple(m_strCalleePrefix, true);
            _ds.displaySimple(m_iCalleePrefixPriority, true);
            _ds.displaySimple(m_strConfAccoutPrefix, true);
            _ds.displaySimple(m_strSBCIp, true);
            _ds.displaySimple(m_iSBCPort, true);
            _ds.displaySimple(m_strRegistarIp, true);
            _ds.displaySimple(m_iRegistarPort, true);
            _ds.displaySimple(m_fromSipAddrType, true);
            _ds.displaySimple(m_toSipAddrType, false);
            return _os;
        }
    public:
        std::string m_strDomainIdAppId;
        std::string m_strDomainName;
        std::string m_strAppKey;
        std::string m_strRelationType;
        tars::Bool m_bAuthorited;
        tars::Bool m_bCharged;
        tars::Bool m_bRegWhenLogined;
        tars::Bool m_bForbitFailedReReg;
        tars::Int32 m_iMaxFailedReRegTimes;
        tars::Bool m_bAllowReRegInterval;
        tars::Int32 m_iFailedReRegInterval;
        tars::Bool m_bISBCAccessed;
        tars::Int32 m_sipBindType;
        std::string m_strCoreNetIdName;
        std::string m_strCalleePrefix;
        tars::Int32 m_iCalleePrefixPriority;
        std::string m_strConfAccoutPrefix;
        std::string m_strSBCIp;
        tars::Int32 m_iSBCPort;
        std::string m_strRegistarIp;
        tars::Int32 m_iRegistarPort;
        tars::Int32 m_fromSipAddrType;
        tars::Int32 m_toSipAddrType;
    };
    inline bool operator==(const DomainAccessedConfig&l, const DomainAccessedConfig&r)
    {
        return l.m_strDomainIdAppId == r.m_strDomainIdAppId && l.m_strDomainName == r.m_strDomainName && l.m_strAppKey == r.m_strAppKey && l.m_strRelationType == r.m_strRelationType && l.m_bAuthorited == r.m_bAuthorited && l.m_bCharged == r.m_bCharged && l.m_bRegWhenLogined == r.m_bRegWhenLogined && l.m_bForbitFailedReReg == r.m_bForbitFailedReReg && l.m_iMaxFailedReRegTimes == r.m_iMaxFailedReRegTimes && l.m_bAllowReRegInterval == r.m_bAllowReRegInterval && l.m_iFailedReRegInterval == r.m_iFailedReRegInterval && l.m_bISBCAccessed == r.m_bISBCAccessed && l.m_sipBindType == r.m_sipBindType && l.m_strCoreNetIdName == r.m_strCoreNetIdName && l.m_strCalleePrefix == r.m_strCalleePrefix && l.m_iCalleePrefixPriority == r.m_iCalleePrefixPriority && l.m_strConfAccoutPrefix == r.m_strConfAccoutPrefix && l.m_strSBCIp == r.m_strSBCIp && l.m_iSBCPort == r.m_iSBCPort && l.m_strRegistarIp == r.m_strRegistarIp && l.m_iRegistarPort == r.m_iRegistarPort && l.m_fromSipAddrType == r.m_fromSipAddrType && l.m_toSipAddrType == r.m_toSipAddrType;
    }
    inline bool operator!=(const DomainAccessedConfig&l, const DomainAccessedConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DomainAccessedConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DomainAccessedConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DomainAccessedConfig2 : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.DomainAccessedConfig2";
        }
        static string MD5()
        {
            return "109eb9a767c9226d90959d0c436ce2d1";
        }
        DomainAccessedConfig2()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_strDomainIdAppId = "";
            m_strDomainName = "";
            m_strAppKey = "";
            m_strRelationType = "";
            m_bAuthorited = false;
            m_bCharged = false;
            m_iAuthorited = 0;
            m_iCharged = 0;
            m_bRegWhenLogined = false;
            m_bForbitFailedReReg = false;
            m_iMaxFailedReRegTimes = 0;
            m_bAllowReRegInterval = false;
            m_iFailedReRegInterval = 0;
            m_bISBCAccessed = false;
            m_sipBindType = 0;
            m_strCoreNetIdName = "";
            m_strCalleePrefix = "";
            m_iCalleePrefixPriority = 0;
            m_strConfAccoutPrefix = "";
            m_strSBCIp = "";
            m_iSBCPort = 0;
            m_strRegistarIp = "";
            m_iRegistarPort = 0;
            m_fromSipAddrType = 0;
            m_toSipAddrType = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_strDomainIdAppId, 0);
            _os.write(m_strDomainName, 1);
            _os.write(m_strAppKey, 2);
            _os.write(m_strRelationType, 3);
            _os.write(m_bAuthorited, 4);
            _os.write(m_bCharged, 5);
            _os.write(m_iAuthorited, 6);
            _os.write(m_iCharged, 7);
            _os.write(m_bRegWhenLogined, 8);
            _os.write(m_bForbitFailedReReg, 9);
            _os.write(m_iMaxFailedReRegTimes, 10);
            _os.write(m_bAllowReRegInterval, 11);
            _os.write(m_iFailedReRegInterval, 12);
            _os.write(m_bISBCAccessed, 13);
            _os.write(m_sipBindType, 14);
            _os.write(m_strCoreNetIdName, 15);
            _os.write(m_strCalleePrefix, 16);
            _os.write(m_iCalleePrefixPriority, 17);
            _os.write(m_strConfAccoutPrefix, 18);
            _os.write(m_strSBCIp, 19);
            _os.write(m_iSBCPort, 20);
            _os.write(m_strRegistarIp, 21);
            _os.write(m_iRegistarPort, 22);
            if (m_fromSipAddrType != 0)
            {
                _os.write(m_fromSipAddrType, 23);
            }
            if (m_toSipAddrType != 0)
            {
                _os.write(m_toSipAddrType, 24);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_strDomainIdAppId, 0, true);
            _is.read(m_strDomainName, 1, true);
            _is.read(m_strAppKey, 2, true);
            _is.read(m_strRelationType, 3, true);
            _is.read(m_bAuthorited, 4, true);
            _is.read(m_bCharged, 5, true);
            _is.read(m_iAuthorited, 6, true);
            _is.read(m_iCharged, 7, true);
            _is.read(m_bRegWhenLogined, 8, true);
            _is.read(m_bForbitFailedReReg, 9, true);
            _is.read(m_iMaxFailedReRegTimes, 10, true);
            _is.read(m_bAllowReRegInterval, 11, true);
            _is.read(m_iFailedReRegInterval, 12, true);
            _is.read(m_bISBCAccessed, 13, true);
            _is.read(m_sipBindType, 14, true);
            _is.read(m_strCoreNetIdName, 15, true);
            _is.read(m_strCalleePrefix, 16, true);
            _is.read(m_iCalleePrefixPriority, 17, true);
            _is.read(m_strConfAccoutPrefix, 18, true);
            _is.read(m_strSBCIp, 19, true);
            _is.read(m_iSBCPort, 20, true);
            _is.read(m_strRegistarIp, 21, true);
            _is.read(m_iRegistarPort, 22, true);
            _is.read(m_fromSipAddrType, 23, false);
            _is.read(m_toSipAddrType, 24, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_strDomainIdAppId"] = tars::JsonOutput::writeJson(m_strDomainIdAppId);
            p->value["m_strDomainName"] = tars::JsonOutput::writeJson(m_strDomainName);
            p->value["m_strAppKey"] = tars::JsonOutput::writeJson(m_strAppKey);
            p->value["m_strRelationType"] = tars::JsonOutput::writeJson(m_strRelationType);
            p->value["m_bAuthorited"] = tars::JsonOutput::writeJson(m_bAuthorited);
            p->value["m_bCharged"] = tars::JsonOutput::writeJson(m_bCharged);
            p->value["m_iAuthorited"] = tars::JsonOutput::writeJson(m_iAuthorited);
            p->value["m_iCharged"] = tars::JsonOutput::writeJson(m_iCharged);
            p->value["m_bRegWhenLogined"] = tars::JsonOutput::writeJson(m_bRegWhenLogined);
            p->value["m_bForbitFailedReReg"] = tars::JsonOutput::writeJson(m_bForbitFailedReReg);
            p->value["m_iMaxFailedReRegTimes"] = tars::JsonOutput::writeJson(m_iMaxFailedReRegTimes);
            p->value["m_bAllowReRegInterval"] = tars::JsonOutput::writeJson(m_bAllowReRegInterval);
            p->value["m_iFailedReRegInterval"] = tars::JsonOutput::writeJson(m_iFailedReRegInterval);
            p->value["m_bISBCAccessed"] = tars::JsonOutput::writeJson(m_bISBCAccessed);
            p->value["m_sipBindType"] = tars::JsonOutput::writeJson(m_sipBindType);
            p->value["m_strCoreNetIdName"] = tars::JsonOutput::writeJson(m_strCoreNetIdName);
            p->value["m_strCalleePrefix"] = tars::JsonOutput::writeJson(m_strCalleePrefix);
            p->value["m_iCalleePrefixPriority"] = tars::JsonOutput::writeJson(m_iCalleePrefixPriority);
            p->value["m_strConfAccoutPrefix"] = tars::JsonOutput::writeJson(m_strConfAccoutPrefix);
            p->value["m_strSBCIp"] = tars::JsonOutput::writeJson(m_strSBCIp);
            p->value["m_iSBCPort"] = tars::JsonOutput::writeJson(m_iSBCPort);
            p->value["m_strRegistarIp"] = tars::JsonOutput::writeJson(m_strRegistarIp);
            p->value["m_iRegistarPort"] = tars::JsonOutput::writeJson(m_iRegistarPort);
            p->value["m_fromSipAddrType"] = tars::JsonOutput::writeJson(m_fromSipAddrType);
            p->value["m_toSipAddrType"] = tars::JsonOutput::writeJson(m_toSipAddrType);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_strDomainIdAppId,pObj->value["m_strDomainIdAppId"], true);
            tars::JsonInput::readJson(m_strDomainName,pObj->value["m_strDomainName"], true);
            tars::JsonInput::readJson(m_strAppKey,pObj->value["m_strAppKey"], true);
            tars::JsonInput::readJson(m_strRelationType,pObj->value["m_strRelationType"], true);
            tars::JsonInput::readJson(m_bAuthorited,pObj->value["m_bAuthorited"], true);
            tars::JsonInput::readJson(m_bCharged,pObj->value["m_bCharged"], true);
            tars::JsonInput::readJson(m_iAuthorited,pObj->value["m_iAuthorited"], true);
            tars::JsonInput::readJson(m_iCharged,pObj->value["m_iCharged"], true);
            tars::JsonInput::readJson(m_bRegWhenLogined,pObj->value["m_bRegWhenLogined"], true);
            tars::JsonInput::readJson(m_bForbitFailedReReg,pObj->value["m_bForbitFailedReReg"], true);
            tars::JsonInput::readJson(m_iMaxFailedReRegTimes,pObj->value["m_iMaxFailedReRegTimes"], true);
            tars::JsonInput::readJson(m_bAllowReRegInterval,pObj->value["m_bAllowReRegInterval"], true);
            tars::JsonInput::readJson(m_iFailedReRegInterval,pObj->value["m_iFailedReRegInterval"], true);
            tars::JsonInput::readJson(m_bISBCAccessed,pObj->value["m_bISBCAccessed"], true);
            tars::JsonInput::readJson(m_sipBindType,pObj->value["m_sipBindType"], true);
            tars::JsonInput::readJson(m_strCoreNetIdName,pObj->value["m_strCoreNetIdName"], true);
            tars::JsonInput::readJson(m_strCalleePrefix,pObj->value["m_strCalleePrefix"], true);
            tars::JsonInput::readJson(m_iCalleePrefixPriority,pObj->value["m_iCalleePrefixPriority"], true);
            tars::JsonInput::readJson(m_strConfAccoutPrefix,pObj->value["m_strConfAccoutPrefix"], true);
            tars::JsonInput::readJson(m_strSBCIp,pObj->value["m_strSBCIp"], true);
            tars::JsonInput::readJson(m_iSBCPort,pObj->value["m_iSBCPort"], true);
            tars::JsonInput::readJson(m_strRegistarIp,pObj->value["m_strRegistarIp"], true);
            tars::JsonInput::readJson(m_iRegistarPort,pObj->value["m_iRegistarPort"], true);
            tars::JsonInput::readJson(m_fromSipAddrType,pObj->value["m_fromSipAddrType"], false);
            tars::JsonInput::readJson(m_toSipAddrType,pObj->value["m_toSipAddrType"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_strDomainIdAppId,"m_strDomainIdAppId");
            _ds.display(m_strDomainName,"m_strDomainName");
            _ds.display(m_strAppKey,"m_strAppKey");
            _ds.display(m_strRelationType,"m_strRelationType");
            _ds.display(m_bAuthorited,"m_bAuthorited");
            _ds.display(m_bCharged,"m_bCharged");
            _ds.display(m_iAuthorited,"m_iAuthorited");
            _ds.display(m_iCharged,"m_iCharged");
            _ds.display(m_bRegWhenLogined,"m_bRegWhenLogined");
            _ds.display(m_bForbitFailedReReg,"m_bForbitFailedReReg");
            _ds.display(m_iMaxFailedReRegTimes,"m_iMaxFailedReRegTimes");
            _ds.display(m_bAllowReRegInterval,"m_bAllowReRegInterval");
            _ds.display(m_iFailedReRegInterval,"m_iFailedReRegInterval");
            _ds.display(m_bISBCAccessed,"m_bISBCAccessed");
            _ds.display(m_sipBindType,"m_sipBindType");
            _ds.display(m_strCoreNetIdName,"m_strCoreNetIdName");
            _ds.display(m_strCalleePrefix,"m_strCalleePrefix");
            _ds.display(m_iCalleePrefixPriority,"m_iCalleePrefixPriority");
            _ds.display(m_strConfAccoutPrefix,"m_strConfAccoutPrefix");
            _ds.display(m_strSBCIp,"m_strSBCIp");
            _ds.display(m_iSBCPort,"m_iSBCPort");
            _ds.display(m_strRegistarIp,"m_strRegistarIp");
            _ds.display(m_iRegistarPort,"m_iRegistarPort");
            _ds.display(m_fromSipAddrType,"m_fromSipAddrType");
            _ds.display(m_toSipAddrType,"m_toSipAddrType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_strDomainIdAppId, true);
            _ds.displaySimple(m_strDomainName, true);
            _ds.displaySimple(m_strAppKey, true);
            _ds.displaySimple(m_strRelationType, true);
            _ds.displaySimple(m_bAuthorited, true);
            _ds.displaySimple(m_bCharged, true);
            _ds.displaySimple(m_iAuthorited, true);
            _ds.displaySimple(m_iCharged, true);
            _ds.displaySimple(m_bRegWhenLogined, true);
            _ds.displaySimple(m_bForbitFailedReReg, true);
            _ds.displaySimple(m_iMaxFailedReRegTimes, true);
            _ds.displaySimple(m_bAllowReRegInterval, true);
            _ds.displaySimple(m_iFailedReRegInterval, true);
            _ds.displaySimple(m_bISBCAccessed, true);
            _ds.displaySimple(m_sipBindType, true);
            _ds.displaySimple(m_strCoreNetIdName, true);
            _ds.displaySimple(m_strCalleePrefix, true);
            _ds.displaySimple(m_iCalleePrefixPriority, true);
            _ds.displaySimple(m_strConfAccoutPrefix, true);
            _ds.displaySimple(m_strSBCIp, true);
            _ds.displaySimple(m_iSBCPort, true);
            _ds.displaySimple(m_strRegistarIp, true);
            _ds.displaySimple(m_iRegistarPort, true);
            _ds.displaySimple(m_fromSipAddrType, true);
            _ds.displaySimple(m_toSipAddrType, false);
            return _os;
        }
    public:
        std::string m_strDomainIdAppId;
        std::string m_strDomainName;
        std::string m_strAppKey;
        std::string m_strRelationType;
        tars::Bool m_bAuthorited;
        tars::Bool m_bCharged;
        tars::Int32 m_iAuthorited;
        tars::Int32 m_iCharged;
        tars::Bool m_bRegWhenLogined;
        tars::Bool m_bForbitFailedReReg;
        tars::Int32 m_iMaxFailedReRegTimes;
        tars::Bool m_bAllowReRegInterval;
        tars::Int32 m_iFailedReRegInterval;
        tars::Bool m_bISBCAccessed;
        tars::Int32 m_sipBindType;
        std::string m_strCoreNetIdName;
        std::string m_strCalleePrefix;
        tars::Int32 m_iCalleePrefixPriority;
        std::string m_strConfAccoutPrefix;
        std::string m_strSBCIp;
        tars::Int32 m_iSBCPort;
        std::string m_strRegistarIp;
        tars::Int32 m_iRegistarPort;
        tars::Int32 m_fromSipAddrType;
        tars::Int32 m_toSipAddrType;
    };
    inline bool operator==(const DomainAccessedConfig2&l, const DomainAccessedConfig2&r)
    {
        return l.m_strDomainIdAppId == r.m_strDomainIdAppId && l.m_strDomainName == r.m_strDomainName && l.m_strAppKey == r.m_strAppKey && l.m_strRelationType == r.m_strRelationType && l.m_bAuthorited == r.m_bAuthorited && l.m_bCharged == r.m_bCharged && l.m_iAuthorited == r.m_iAuthorited && l.m_iCharged == r.m_iCharged && l.m_bRegWhenLogined == r.m_bRegWhenLogined && l.m_bForbitFailedReReg == r.m_bForbitFailedReReg && l.m_iMaxFailedReRegTimes == r.m_iMaxFailedReRegTimes && l.m_bAllowReRegInterval == r.m_bAllowReRegInterval && l.m_iFailedReRegInterval == r.m_iFailedReRegInterval && l.m_bISBCAccessed == r.m_bISBCAccessed && l.m_sipBindType == r.m_sipBindType && l.m_strCoreNetIdName == r.m_strCoreNetIdName && l.m_strCalleePrefix == r.m_strCalleePrefix && l.m_iCalleePrefixPriority == r.m_iCalleePrefixPriority && l.m_strConfAccoutPrefix == r.m_strConfAccoutPrefix && l.m_strSBCIp == r.m_strSBCIp && l.m_iSBCPort == r.m_iSBCPort && l.m_strRegistarIp == r.m_strRegistarIp && l.m_iRegistarPort == r.m_iRegistarPort && l.m_fromSipAddrType == r.m_fromSipAddrType && l.m_toSipAddrType == r.m_toSipAddrType;
    }
    inline bool operator!=(const DomainAccessedConfig2&l, const DomainAccessedConfig2&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DomainAccessedConfig2&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DomainAccessedConfig2&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipProxyAccessedCoreNetConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipProxyAccessedCoreNetConfig";
        }
        static string MD5()
        {
            return "641f9070f5c95907d4222d07069a2c9d";
        }
        SipProxyAccessedCoreNetConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_strSipProxyName = "";
            m_bISBCAccessed = false;
            m_strSipProxyId = "";
            m_strCoreNetIdName = "";
            m_strSBCIp = "";
            m_iSBCPort = 0;
            m_listenIp = "";
            m_listenPort = 0;
            m_sendIp = "";
            m_sendPort = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_strSipProxyName, 0);
            _os.write(m_bISBCAccessed, 1);
            _os.write(m_strSipProxyId, 2);
            _os.write(m_strCoreNetIdName, 3);
            _os.write(m_strSBCIp, 4);
            _os.write(m_iSBCPort, 5);
            _os.write(m_listenIp, 6);
            _os.write(m_listenPort, 7);
            _os.write(m_sendIp, 8);
            _os.write(m_sendPort, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_strSipProxyName, 0, true);
            _is.read(m_bISBCAccessed, 1, true);
            _is.read(m_strSipProxyId, 2, true);
            _is.read(m_strCoreNetIdName, 3, true);
            _is.read(m_strSBCIp, 4, true);
            _is.read(m_iSBCPort, 5, true);
            _is.read(m_listenIp, 6, true);
            _is.read(m_listenPort, 7, true);
            _is.read(m_sendIp, 8, true);
            _is.read(m_sendPort, 9, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_strSipProxyName"] = tars::JsonOutput::writeJson(m_strSipProxyName);
            p->value["m_bISBCAccessed"] = tars::JsonOutput::writeJson(m_bISBCAccessed);
            p->value["m_strSipProxyId"] = tars::JsonOutput::writeJson(m_strSipProxyId);
            p->value["m_strCoreNetIdName"] = tars::JsonOutput::writeJson(m_strCoreNetIdName);
            p->value["m_strSBCIp"] = tars::JsonOutput::writeJson(m_strSBCIp);
            p->value["m_iSBCPort"] = tars::JsonOutput::writeJson(m_iSBCPort);
            p->value["m_listenIp"] = tars::JsonOutput::writeJson(m_listenIp);
            p->value["m_listenPort"] = tars::JsonOutput::writeJson(m_listenPort);
            p->value["m_sendIp"] = tars::JsonOutput::writeJson(m_sendIp);
            p->value["m_sendPort"] = tars::JsonOutput::writeJson(m_sendPort);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_strSipProxyName,pObj->value["m_strSipProxyName"], true);
            tars::JsonInput::readJson(m_bISBCAccessed,pObj->value["m_bISBCAccessed"], true);
            tars::JsonInput::readJson(m_strSipProxyId,pObj->value["m_strSipProxyId"], true);
            tars::JsonInput::readJson(m_strCoreNetIdName,pObj->value["m_strCoreNetIdName"], true);
            tars::JsonInput::readJson(m_strSBCIp,pObj->value["m_strSBCIp"], true);
            tars::JsonInput::readJson(m_iSBCPort,pObj->value["m_iSBCPort"], true);
            tars::JsonInput::readJson(m_listenIp,pObj->value["m_listenIp"], true);
            tars::JsonInput::readJson(m_listenPort,pObj->value["m_listenPort"], true);
            tars::JsonInput::readJson(m_sendIp,pObj->value["m_sendIp"], true);
            tars::JsonInput::readJson(m_sendPort,pObj->value["m_sendPort"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_strSipProxyName,"m_strSipProxyName");
            _ds.display(m_bISBCAccessed,"m_bISBCAccessed");
            _ds.display(m_strSipProxyId,"m_strSipProxyId");
            _ds.display(m_strCoreNetIdName,"m_strCoreNetIdName");
            _ds.display(m_strSBCIp,"m_strSBCIp");
            _ds.display(m_iSBCPort,"m_iSBCPort");
            _ds.display(m_listenIp,"m_listenIp");
            _ds.display(m_listenPort,"m_listenPort");
            _ds.display(m_sendIp,"m_sendIp");
            _ds.display(m_sendPort,"m_sendPort");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_strSipProxyName, true);
            _ds.displaySimple(m_bISBCAccessed, true);
            _ds.displaySimple(m_strSipProxyId, true);
            _ds.displaySimple(m_strCoreNetIdName, true);
            _ds.displaySimple(m_strSBCIp, true);
            _ds.displaySimple(m_iSBCPort, true);
            _ds.displaySimple(m_listenIp, true);
            _ds.displaySimple(m_listenPort, true);
            _ds.displaySimple(m_sendIp, true);
            _ds.displaySimple(m_sendPort, false);
            return _os;
        }
    public:
        std::string m_strSipProxyName;
        tars::Bool m_bISBCAccessed;
        std::string m_strSipProxyId;
        std::string m_strCoreNetIdName;
        std::string m_strSBCIp;
        tars::Int32 m_iSBCPort;
        std::string m_listenIp;
        tars::Int32 m_listenPort;
        std::string m_sendIp;
        tars::Int32 m_sendPort;
    };
    inline bool operator==(const SipProxyAccessedCoreNetConfig&l, const SipProxyAccessedCoreNetConfig&r)
    {
        return l.m_strSipProxyName == r.m_strSipProxyName && l.m_bISBCAccessed == r.m_bISBCAccessed && l.m_strSipProxyId == r.m_strSipProxyId && l.m_strCoreNetIdName == r.m_strCoreNetIdName && l.m_strSBCIp == r.m_strSBCIp && l.m_iSBCPort == r.m_iSBCPort && l.m_listenIp == r.m_listenIp && l.m_listenPort == r.m_listenPort && l.m_sendIp == r.m_sendIp && l.m_sendPort == r.m_sendPort;
    }
    inline bool operator!=(const SipProxyAccessedCoreNetConfig&l, const SipProxyAccessedCoreNetConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipProxyAccessedCoreNetConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipProxyAccessedCoreNetConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipAccountInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipAccountInfo";
        }
        static string MD5()
        {
            return "d6d5eb24ebf89f4b74e2498d949af79f";
        }
        SipAccountInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_sipUri = "";
            m_strAccountId = "";
            m_strDomainName = "";
            m_strDomainId = "";
            m_strAppId = "";
            m_strCoreNetId = "";
            m_strPassWord = "";
            m_strAuthName = "";
            m_strSipProxyName = "";
            m_strAppAccount = "";
            m_strRelationType = "";
            m_strAppAccountNumber = "";
            m_iInUse = 0;
            m_iProxyed = 0;
            m_iLogined = 0;
            m_strSipProxyId = "";
            m_strSBCIp = "";
            m_iSBCport = 0;
            m_strRegistarIp = "";
            m_iRegistarPort = 0;
            m_fromSipAddrType = 0;
            m_toSipAddrType = 0;
            m_lInsertTime = 0;
            m_iPermitedProxyed = 0;
            m_insertDateTime = "";
            m_iFailedRegTimes = 0;
            m_lLastFailedRegTime = 0;
            m_lLoginedTime = 0;
            m_inUseTime = 0;
            m_proxyedTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_sipUri, 0);
            _os.write(m_strAccountId, 1);
            _os.write(m_strDomainName, 2);
            _os.write(m_strDomainId, 3);
            _os.write(m_strAppId, 4);
            _os.write(m_strCoreNetId, 5);
            _os.write(m_strPassWord, 6);
            _os.write(m_strAuthName, 7);
            _os.write(m_strSipProxyName, 8);
            _os.write(m_strAppAccount, 9);
            _os.write(m_strRelationType, 10);
            _os.write(m_strAppAccountNumber, 11);
            _os.write(m_iInUse, 12);
            _os.write(m_iProxyed, 13);
            _os.write(m_iLogined, 14);
            _os.write(m_strSipProxyId, 15);
            _os.write(m_strSBCIp, 16);
            _os.write(m_iSBCport, 17);
            _os.write(m_strRegistarIp, 18);
            _os.write(m_iRegistarPort, 19);
            _os.write(m_fromSipAddrType, 20);
            _os.write(m_toSipAddrType, 21);
            _os.write(m_lInsertTime, 22);
            _os.write(m_iPermitedProxyed, 23);
            _os.write(m_insertDateTime, 24);
            _os.write(m_iFailedRegTimes, 25);
            _os.write(m_lLastFailedRegTime, 26);
            _os.write(m_lLoginedTime, 27);
            _os.write(m_inUseTime, 28);
            _os.write(m_proxyedTime, 29);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_sipUri, 0, true);
            _is.read(m_strAccountId, 1, true);
            _is.read(m_strDomainName, 2, true);
            _is.read(m_strDomainId, 3, true);
            _is.read(m_strAppId, 4, true);
            _is.read(m_strCoreNetId, 5, true);
            _is.read(m_strPassWord, 6, true);
            _is.read(m_strAuthName, 7, true);
            _is.read(m_strSipProxyName, 8, true);
            _is.read(m_strAppAccount, 9, true);
            _is.read(m_strRelationType, 10, true);
            _is.read(m_strAppAccountNumber, 11, true);
            _is.read(m_iInUse, 12, true);
            _is.read(m_iProxyed, 13, true);
            _is.read(m_iLogined, 14, true);
            _is.read(m_strSipProxyId, 15, true);
            _is.read(m_strSBCIp, 16, true);
            _is.read(m_iSBCport, 17, true);
            _is.read(m_strRegistarIp, 18, true);
            _is.read(m_iRegistarPort, 19, true);
            _is.read(m_fromSipAddrType, 20, true);
            _is.read(m_toSipAddrType, 21, true);
            _is.read(m_lInsertTime, 22, true);
            _is.read(m_iPermitedProxyed, 23, true);
            _is.read(m_insertDateTime, 24, true);
            _is.read(m_iFailedRegTimes, 25, true);
            _is.read(m_lLastFailedRegTime, 26, true);
            _is.read(m_lLoginedTime, 27, true);
            _is.read(m_inUseTime, 28, true);
            _is.read(m_proxyedTime, 29, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_sipUri"] = tars::JsonOutput::writeJson(m_sipUri);
            p->value["m_strAccountId"] = tars::JsonOutput::writeJson(m_strAccountId);
            p->value["m_strDomainName"] = tars::JsonOutput::writeJson(m_strDomainName);
            p->value["m_strDomainId"] = tars::JsonOutput::writeJson(m_strDomainId);
            p->value["m_strAppId"] = tars::JsonOutput::writeJson(m_strAppId);
            p->value["m_strCoreNetId"] = tars::JsonOutput::writeJson(m_strCoreNetId);
            p->value["m_strPassWord"] = tars::JsonOutput::writeJson(m_strPassWord);
            p->value["m_strAuthName"] = tars::JsonOutput::writeJson(m_strAuthName);
            p->value["m_strSipProxyName"] = tars::JsonOutput::writeJson(m_strSipProxyName);
            p->value["m_strAppAccount"] = tars::JsonOutput::writeJson(m_strAppAccount);
            p->value["m_strRelationType"] = tars::JsonOutput::writeJson(m_strRelationType);
            p->value["m_strAppAccountNumber"] = tars::JsonOutput::writeJson(m_strAppAccountNumber);
            p->value["m_iInUse"] = tars::JsonOutput::writeJson(m_iInUse);
            p->value["m_iProxyed"] = tars::JsonOutput::writeJson(m_iProxyed);
            p->value["m_iLogined"] = tars::JsonOutput::writeJson(m_iLogined);
            p->value["m_strSipProxyId"] = tars::JsonOutput::writeJson(m_strSipProxyId);
            p->value["m_strSBCIp"] = tars::JsonOutput::writeJson(m_strSBCIp);
            p->value["m_iSBCport"] = tars::JsonOutput::writeJson(m_iSBCport);
            p->value["m_strRegistarIp"] = tars::JsonOutput::writeJson(m_strRegistarIp);
            p->value["m_iRegistarPort"] = tars::JsonOutput::writeJson(m_iRegistarPort);
            p->value["m_fromSipAddrType"] = tars::JsonOutput::writeJson(m_fromSipAddrType);
            p->value["m_toSipAddrType"] = tars::JsonOutput::writeJson(m_toSipAddrType);
            p->value["m_lInsertTime"] = tars::JsonOutput::writeJson(m_lInsertTime);
            p->value["m_iPermitedProxyed"] = tars::JsonOutput::writeJson(m_iPermitedProxyed);
            p->value["m_insertDateTime"] = tars::JsonOutput::writeJson(m_insertDateTime);
            p->value["m_iFailedRegTimes"] = tars::JsonOutput::writeJson(m_iFailedRegTimes);
            p->value["m_lLastFailedRegTime"] = tars::JsonOutput::writeJson(m_lLastFailedRegTime);
            p->value["m_lLoginedTime"] = tars::JsonOutput::writeJson(m_lLoginedTime);
            p->value["m_inUseTime"] = tars::JsonOutput::writeJson(m_inUseTime);
            p->value["m_proxyedTime"] = tars::JsonOutput::writeJson(m_proxyedTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_sipUri,pObj->value["m_sipUri"], true);
            tars::JsonInput::readJson(m_strAccountId,pObj->value["m_strAccountId"], true);
            tars::JsonInput::readJson(m_strDomainName,pObj->value["m_strDomainName"], true);
            tars::JsonInput::readJson(m_strDomainId,pObj->value["m_strDomainId"], true);
            tars::JsonInput::readJson(m_strAppId,pObj->value["m_strAppId"], true);
            tars::JsonInput::readJson(m_strCoreNetId,pObj->value["m_strCoreNetId"], true);
            tars::JsonInput::readJson(m_strPassWord,pObj->value["m_strPassWord"], true);
            tars::JsonInput::readJson(m_strAuthName,pObj->value["m_strAuthName"], true);
            tars::JsonInput::readJson(m_strSipProxyName,pObj->value["m_strSipProxyName"], true);
            tars::JsonInput::readJson(m_strAppAccount,pObj->value["m_strAppAccount"], true);
            tars::JsonInput::readJson(m_strRelationType,pObj->value["m_strRelationType"], true);
            tars::JsonInput::readJson(m_strAppAccountNumber,pObj->value["m_strAppAccountNumber"], true);
            tars::JsonInput::readJson(m_iInUse,pObj->value["m_iInUse"], true);
            tars::JsonInput::readJson(m_iProxyed,pObj->value["m_iProxyed"], true);
            tars::JsonInput::readJson(m_iLogined,pObj->value["m_iLogined"], true);
            tars::JsonInput::readJson(m_strSipProxyId,pObj->value["m_strSipProxyId"], true);
            tars::JsonInput::readJson(m_strSBCIp,pObj->value["m_strSBCIp"], true);
            tars::JsonInput::readJson(m_iSBCport,pObj->value["m_iSBCport"], true);
            tars::JsonInput::readJson(m_strRegistarIp,pObj->value["m_strRegistarIp"], true);
            tars::JsonInput::readJson(m_iRegistarPort,pObj->value["m_iRegistarPort"], true);
            tars::JsonInput::readJson(m_fromSipAddrType,pObj->value["m_fromSipAddrType"], true);
            tars::JsonInput::readJson(m_toSipAddrType,pObj->value["m_toSipAddrType"], true);
            tars::JsonInput::readJson(m_lInsertTime,pObj->value["m_lInsertTime"], true);
            tars::JsonInput::readJson(m_iPermitedProxyed,pObj->value["m_iPermitedProxyed"], true);
            tars::JsonInput::readJson(m_insertDateTime,pObj->value["m_insertDateTime"], true);
            tars::JsonInput::readJson(m_iFailedRegTimes,pObj->value["m_iFailedRegTimes"], true);
            tars::JsonInput::readJson(m_lLastFailedRegTime,pObj->value["m_lLastFailedRegTime"], true);
            tars::JsonInput::readJson(m_lLoginedTime,pObj->value["m_lLoginedTime"], true);
            tars::JsonInput::readJson(m_inUseTime,pObj->value["m_inUseTime"], true);
            tars::JsonInput::readJson(m_proxyedTime,pObj->value["m_proxyedTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_sipUri,"m_sipUri");
            _ds.display(m_strAccountId,"m_strAccountId");
            _ds.display(m_strDomainName,"m_strDomainName");
            _ds.display(m_strDomainId,"m_strDomainId");
            _ds.display(m_strAppId,"m_strAppId");
            _ds.display(m_strCoreNetId,"m_strCoreNetId");
            _ds.display(m_strPassWord,"m_strPassWord");
            _ds.display(m_strAuthName,"m_strAuthName");
            _ds.display(m_strSipProxyName,"m_strSipProxyName");
            _ds.display(m_strAppAccount,"m_strAppAccount");
            _ds.display(m_strRelationType,"m_strRelationType");
            _ds.display(m_strAppAccountNumber,"m_strAppAccountNumber");
            _ds.display(m_iInUse,"m_iInUse");
            _ds.display(m_iProxyed,"m_iProxyed");
            _ds.display(m_iLogined,"m_iLogined");
            _ds.display(m_strSipProxyId,"m_strSipProxyId");
            _ds.display(m_strSBCIp,"m_strSBCIp");
            _ds.display(m_iSBCport,"m_iSBCport");
            _ds.display(m_strRegistarIp,"m_strRegistarIp");
            _ds.display(m_iRegistarPort,"m_iRegistarPort");
            _ds.display(m_fromSipAddrType,"m_fromSipAddrType");
            _ds.display(m_toSipAddrType,"m_toSipAddrType");
            _ds.display(m_lInsertTime,"m_lInsertTime");
            _ds.display(m_iPermitedProxyed,"m_iPermitedProxyed");
            _ds.display(m_insertDateTime,"m_insertDateTime");
            _ds.display(m_iFailedRegTimes,"m_iFailedRegTimes");
            _ds.display(m_lLastFailedRegTime,"m_lLastFailedRegTime");
            _ds.display(m_lLoginedTime,"m_lLoginedTime");
            _ds.display(m_inUseTime,"m_inUseTime");
            _ds.display(m_proxyedTime,"m_proxyedTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_sipUri, true);
            _ds.displaySimple(m_strAccountId, true);
            _ds.displaySimple(m_strDomainName, true);
            _ds.displaySimple(m_strDomainId, true);
            _ds.displaySimple(m_strAppId, true);
            _ds.displaySimple(m_strCoreNetId, true);
            _ds.displaySimple(m_strPassWord, true);
            _ds.displaySimple(m_strAuthName, true);
            _ds.displaySimple(m_strSipProxyName, true);
            _ds.displaySimple(m_strAppAccount, true);
            _ds.displaySimple(m_strRelationType, true);
            _ds.displaySimple(m_strAppAccountNumber, true);
            _ds.displaySimple(m_iInUse, true);
            _ds.displaySimple(m_iProxyed, true);
            _ds.displaySimple(m_iLogined, true);
            _ds.displaySimple(m_strSipProxyId, true);
            _ds.displaySimple(m_strSBCIp, true);
            _ds.displaySimple(m_iSBCport, true);
            _ds.displaySimple(m_strRegistarIp, true);
            _ds.displaySimple(m_iRegistarPort, true);
            _ds.displaySimple(m_fromSipAddrType, true);
            _ds.displaySimple(m_toSipAddrType, true);
            _ds.displaySimple(m_lInsertTime, true);
            _ds.displaySimple(m_iPermitedProxyed, true);
            _ds.displaySimple(m_insertDateTime, true);
            _ds.displaySimple(m_iFailedRegTimes, true);
            _ds.displaySimple(m_lLastFailedRegTime, true);
            _ds.displaySimple(m_lLoginedTime, true);
            _ds.displaySimple(m_inUseTime, true);
            _ds.displaySimple(m_proxyedTime, false);
            return _os;
        }
    public:
        std::string m_sipUri;
        std::string m_strAccountId;
        std::string m_strDomainName;
        std::string m_strDomainId;
        std::string m_strAppId;
        std::string m_strCoreNetId;
        std::string m_strPassWord;
        std::string m_strAuthName;
        std::string m_strSipProxyName;
        std::string m_strAppAccount;
        std::string m_strRelationType;
        std::string m_strAppAccountNumber;
        tars::Int32 m_iInUse;
        tars::Int32 m_iProxyed;
        tars::Int32 m_iLogined;
        std::string m_strSipProxyId;
        std::string m_strSBCIp;
        tars::Int32 m_iSBCport;
        std::string m_strRegistarIp;
        tars::Int32 m_iRegistarPort;
        tars::Int32 m_fromSipAddrType;
        tars::Int32 m_toSipAddrType;
        tars::Int64 m_lInsertTime;
        tars::Int32 m_iPermitedProxyed;
        std::string m_insertDateTime;
        tars::Int32 m_iFailedRegTimes;
        tars::Int64 m_lLastFailedRegTime;
        tars::Int64 m_lLoginedTime;
        tars::Int64 m_inUseTime;
        tars::Int64 m_proxyedTime;
    };
    inline bool operator==(const SipAccountInfo&l, const SipAccountInfo&r)
    {
        return l.m_sipUri == r.m_sipUri && l.m_strAccountId == r.m_strAccountId && l.m_strDomainName == r.m_strDomainName && l.m_strDomainId == r.m_strDomainId && l.m_strAppId == r.m_strAppId && l.m_strCoreNetId == r.m_strCoreNetId && l.m_strPassWord == r.m_strPassWord && l.m_strAuthName == r.m_strAuthName && l.m_strSipProxyName == r.m_strSipProxyName && l.m_strAppAccount == r.m_strAppAccount && l.m_strRelationType == r.m_strRelationType && l.m_strAppAccountNumber == r.m_strAppAccountNumber && l.m_iInUse == r.m_iInUse && l.m_iProxyed == r.m_iProxyed && l.m_iLogined == r.m_iLogined && l.m_strSipProxyId == r.m_strSipProxyId && l.m_strSBCIp == r.m_strSBCIp && l.m_iSBCport == r.m_iSBCport && l.m_strRegistarIp == r.m_strRegistarIp && l.m_iRegistarPort == r.m_iRegistarPort && l.m_fromSipAddrType == r.m_fromSipAddrType && l.m_toSipAddrType == r.m_toSipAddrType && l.m_lInsertTime == r.m_lInsertTime && l.m_iPermitedProxyed == r.m_iPermitedProxyed && l.m_insertDateTime == r.m_insertDateTime && l.m_iFailedRegTimes == r.m_iFailedRegTimes && l.m_lLastFailedRegTime == r.m_lLastFailedRegTime && l.m_lLoginedTime == r.m_lLoginedTime && l.m_inUseTime == r.m_inUseTime && l.m_proxyedTime == r.m_proxyedTime;
    }
    inline bool operator!=(const SipAccountInfo&l, const SipAccountInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipAccountInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipAccountInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipAccountInfoOperation : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipAccountInfoOperation";
        }
        static string MD5()
        {
            return "97d06dc93e1fcdf0086dd05b31e83201";
        }
        SipAccountInfoOperation()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            OpCategory = VoipApp::kOperationCategoryUnknown;
            sipAccountInfo.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)OpCategory, 0);
            _os.write(sipAccountInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = VoipApp::kOperationCategoryUnknown;
            _is.read(eTemp0, 0, true);
            OpCategory = (VoipApp::OperationCategory)eTemp0;
            _is.read(sipAccountInfo, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["OpCategory"] = tars::JsonOutput::writeJson((tars::Int32)OpCategory);
            p->value["sipAccountInfo"] = tars::JsonOutput::writeJson(sipAccountInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(OpCategory,pObj->value["OpCategory"], true);
            tars::JsonInput::readJson(sipAccountInfo,pObj->value["sipAccountInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)OpCategory,"OpCategory");
            _ds.display(sipAccountInfo,"sipAccountInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)OpCategory, true);
            _ds.displaySimple(sipAccountInfo, false);
            return _os;
        }
    public:
        VoipApp::OperationCategory OpCategory;
        VoipApp::SipAccountInfo sipAccountInfo;
    };
    inline bool operator==(const SipAccountInfoOperation&l, const SipAccountInfoOperation&r)
    {
        return l.OpCategory == r.OpCategory && l.sipAccountInfo == r.sipAccountInfo;
    }
    inline bool operator!=(const SipAccountInfoOperation&l, const SipAccountInfoOperation&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipAccountInfoOperation&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipAccountInfoOperation&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DomainAccessConfigOperation : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.DomainAccessConfigOperation";
        }
        static string MD5()
        {
            return "31ce256b1b3e43a9c00bc95a715018ad";
        }
        DomainAccessConfigOperation()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_category = VoipApp::kOperationCategoryUnknown;
            m_domainConfig.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)m_category, 0);
            _os.write(m_domainConfig, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = VoipApp::kOperationCategoryUnknown;
            _is.read(eTemp0, 0, true);
            m_category = (VoipApp::OperationCategory)eTemp0;
            _is.read(m_domainConfig, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_category"] = tars::JsonOutput::writeJson((tars::Int32)m_category);
            p->value["m_domainConfig"] = tars::JsonOutput::writeJson(m_domainConfig);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_category,pObj->value["m_category"], true);
            tars::JsonInput::readJson(m_domainConfig,pObj->value["m_domainConfig"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)m_category,"m_category");
            _ds.display(m_domainConfig,"m_domainConfig");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)m_category, true);
            _ds.displaySimple(m_domainConfig, false);
            return _os;
        }
    public:
        VoipApp::OperationCategory m_category;
        VoipApp::DomainAccessedConfig m_domainConfig;
    };
    inline bool operator==(const DomainAccessConfigOperation&l, const DomainAccessConfigOperation&r)
    {
        return l.m_category == r.m_category && l.m_domainConfig == r.m_domainConfig;
    }
    inline bool operator!=(const DomainAccessConfigOperation&l, const DomainAccessConfigOperation&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DomainAccessConfigOperation&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DomainAccessConfigOperation&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DomainAccessConfigOperation2 : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.DomainAccessConfigOperation2";
        }
        static string MD5()
        {
            return "5f238e52d20a7c669ad6da3c17a05a8e";
        }
        DomainAccessConfigOperation2()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_category = VoipApp::kOperationCategoryUnknown;
            m_domainConfig.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)m_category, 0);
            _os.write(m_domainConfig, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = VoipApp::kOperationCategoryUnknown;
            _is.read(eTemp0, 0, true);
            m_category = (VoipApp::OperationCategory)eTemp0;
            _is.read(m_domainConfig, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_category"] = tars::JsonOutput::writeJson((tars::Int32)m_category);
            p->value["m_domainConfig"] = tars::JsonOutput::writeJson(m_domainConfig);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_category,pObj->value["m_category"], true);
            tars::JsonInput::readJson(m_domainConfig,pObj->value["m_domainConfig"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)m_category,"m_category");
            _ds.display(m_domainConfig,"m_domainConfig");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)m_category, true);
            _ds.displaySimple(m_domainConfig, false);
            return _os;
        }
    public:
        VoipApp::OperationCategory m_category;
        VoipApp::DomainAccessedConfig2 m_domainConfig;
    };
    inline bool operator==(const DomainAccessConfigOperation2&l, const DomainAccessConfigOperation2&r)
    {
        return l.m_category == r.m_category && l.m_domainConfig == r.m_domainConfig;
    }
    inline bool operator!=(const DomainAccessConfigOperation2&l, const DomainAccessConfigOperation2&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DomainAccessConfigOperation2&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DomainAccessConfigOperation2&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipProxyConfigOperation : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipProxyConfigOperation";
        }
        static string MD5()
        {
            return "329480e4ad971edc435c041539861cb0";
        }
        SipProxyConfigOperation()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_category = VoipApp::kOperationCategoryUnknown;
            m_sipProxyConfig.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)m_category, 0);
            _os.write(m_sipProxyConfig, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = VoipApp::kOperationCategoryUnknown;
            _is.read(eTemp0, 0, true);
            m_category = (VoipApp::OperationCategory)eTemp0;
            _is.read(m_sipProxyConfig, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_category"] = tars::JsonOutput::writeJson((tars::Int32)m_category);
            p->value["m_sipProxyConfig"] = tars::JsonOutput::writeJson(m_sipProxyConfig);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_category,pObj->value["m_category"], true);
            tars::JsonInput::readJson(m_sipProxyConfig,pObj->value["m_sipProxyConfig"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)m_category,"m_category");
            _ds.display(m_sipProxyConfig,"m_sipProxyConfig");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)m_category, true);
            _ds.displaySimple(m_sipProxyConfig, false);
            return _os;
        }
    public:
        VoipApp::OperationCategory m_category;
        VoipApp::SipProxyAccessedCoreNetConfig m_sipProxyConfig;
    };
    inline bool operator==(const SipProxyConfigOperation&l, const SipProxyConfigOperation&r)
    {
        return l.m_category == r.m_category && l.m_sipProxyConfig == r.m_sipProxyConfig;
    }
    inline bool operator!=(const SipProxyConfigOperation&l, const SipProxyConfigOperation&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipProxyConfigOperation&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipProxyConfigOperation&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RtpGatewayAccessedConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.RtpGatewayAccessedConfig";
        }
        static string MD5()
        {
            return "77dd2de630e4f50b6d42fedfdbd48788";
        }
        RtpGatewayAccessedConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_rtpGatewayName = "";
            m_listenIp = "";
            m_minMediaPort = 0;
            m_maxMediaPort = 0;
            m_areaCode = 0;
            m_nationCode = 0;
            m_rtpGatewayId = "";
            m_heartBeatTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_rtpGatewayName, 0);
            _os.write(m_listenIp, 1);
            _os.write(m_minMediaPort, 2);
            _os.write(m_maxMediaPort, 3);
            _os.write(m_areaCode, 4);
            _os.write(m_nationCode, 5);
            _os.write(m_rtpGatewayId, 6);
            _os.write(m_heartBeatTime, 7);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_rtpGatewayName, 0, true);
            _is.read(m_listenIp, 1, true);
            _is.read(m_minMediaPort, 2, true);
            _is.read(m_maxMediaPort, 3, true);
            _is.read(m_areaCode, 4, true);
            _is.read(m_nationCode, 5, true);
            _is.read(m_rtpGatewayId, 6, true);
            _is.read(m_heartBeatTime, 7, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_rtpGatewayName"] = tars::JsonOutput::writeJson(m_rtpGatewayName);
            p->value["m_listenIp"] = tars::JsonOutput::writeJson(m_listenIp);
            p->value["m_minMediaPort"] = tars::JsonOutput::writeJson(m_minMediaPort);
            p->value["m_maxMediaPort"] = tars::JsonOutput::writeJson(m_maxMediaPort);
            p->value["m_areaCode"] = tars::JsonOutput::writeJson(m_areaCode);
            p->value["m_nationCode"] = tars::JsonOutput::writeJson(m_nationCode);
            p->value["m_rtpGatewayId"] = tars::JsonOutput::writeJson(m_rtpGatewayId);
            p->value["m_heartBeatTime"] = tars::JsonOutput::writeJson(m_heartBeatTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_rtpGatewayName,pObj->value["m_rtpGatewayName"], true);
            tars::JsonInput::readJson(m_listenIp,pObj->value["m_listenIp"], true);
            tars::JsonInput::readJson(m_minMediaPort,pObj->value["m_minMediaPort"], true);
            tars::JsonInput::readJson(m_maxMediaPort,pObj->value["m_maxMediaPort"], true);
            tars::JsonInput::readJson(m_areaCode,pObj->value["m_areaCode"], true);
            tars::JsonInput::readJson(m_nationCode,pObj->value["m_nationCode"], true);
            tars::JsonInput::readJson(m_rtpGatewayId,pObj->value["m_rtpGatewayId"], true);
            tars::JsonInput::readJson(m_heartBeatTime,pObj->value["m_heartBeatTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_rtpGatewayName,"m_rtpGatewayName");
            _ds.display(m_listenIp,"m_listenIp");
            _ds.display(m_minMediaPort,"m_minMediaPort");
            _ds.display(m_maxMediaPort,"m_maxMediaPort");
            _ds.display(m_areaCode,"m_areaCode");
            _ds.display(m_nationCode,"m_nationCode");
            _ds.display(m_rtpGatewayId,"m_rtpGatewayId");
            _ds.display(m_heartBeatTime,"m_heartBeatTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_rtpGatewayName, true);
            _ds.displaySimple(m_listenIp, true);
            _ds.displaySimple(m_minMediaPort, true);
            _ds.displaySimple(m_maxMediaPort, true);
            _ds.displaySimple(m_areaCode, true);
            _ds.displaySimple(m_nationCode, true);
            _ds.displaySimple(m_rtpGatewayId, true);
            _ds.displaySimple(m_heartBeatTime, false);
            return _os;
        }
    public:
        std::string m_rtpGatewayName;
        std::string m_listenIp;
        tars::Int32 m_minMediaPort;
        tars::Int32 m_maxMediaPort;
        tars::Int32 m_areaCode;
        tars::Int32 m_nationCode;
        std::string m_rtpGatewayId;
        tars::Int64 m_heartBeatTime;
    };
    inline bool operator==(const RtpGatewayAccessedConfig&l, const RtpGatewayAccessedConfig&r)
    {
        return l.m_rtpGatewayName == r.m_rtpGatewayName && l.m_listenIp == r.m_listenIp && l.m_minMediaPort == r.m_minMediaPort && l.m_maxMediaPort == r.m_maxMediaPort && l.m_areaCode == r.m_areaCode && l.m_nationCode == r.m_nationCode && l.m_rtpGatewayId == r.m_rtpGatewayId && l.m_heartBeatTime == r.m_heartBeatTime;
    }
    inline bool operator!=(const RtpGatewayAccessedConfig&l, const RtpGatewayAccessedConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RtpGatewayAccessedConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RtpGatewayAccessedConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipCallRecord : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipCallRecord";
        }
        static string MD5()
        {
            return "ddd599057c67f04cecb50c22864b0493";
        }
        SipCallRecord()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_st = 0;
            m_et = 0;
            m_fromUser = "";
            m_toUser = "";
            m_toPhone = "";
            m_rpcCallId = "";
            m_sipCallId = "";
            m_td = 0;
            m_type = 0;
            m_direction = 0;
            m_confUri = "";
            m_confMid = "";
            m_cmt = 0;
            m_sipGatewayId = "";
            m_sipProxyId = "";
            m_coreNetId = "";
            m_errCode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_st, 0);
            _os.write(m_et, 1);
            _os.write(m_fromUser, 2);
            _os.write(m_toUser, 3);
            _os.write(m_toPhone, 4);
            _os.write(m_rpcCallId, 5);
            _os.write(m_sipCallId, 6);
            _os.write(m_td, 7);
            _os.write(m_type, 8);
            _os.write(m_direction, 9);
            _os.write(m_confUri, 10);
            _os.write(m_confMid, 11);
            _os.write(m_cmt, 12);
            _os.write(m_sipGatewayId, 13);
            _os.write(m_sipProxyId, 14);
            _os.write(m_coreNetId, 15);
            _os.write(m_errCode, 16);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_st, 0, true);
            _is.read(m_et, 1, true);
            _is.read(m_fromUser, 2, true);
            _is.read(m_toUser, 3, true);
            _is.read(m_toPhone, 4, true);
            _is.read(m_rpcCallId, 5, true);
            _is.read(m_sipCallId, 6, true);
            _is.read(m_td, 7, true);
            _is.read(m_type, 8, true);
            _is.read(m_direction, 9, true);
            _is.read(m_confUri, 10, true);
            _is.read(m_confMid, 11, true);
            _is.read(m_cmt, 12, true);
            _is.read(m_sipGatewayId, 13, true);
            _is.read(m_sipProxyId, 14, true);
            _is.read(m_coreNetId, 15, true);
            _is.read(m_errCode, 16, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_st"] = tars::JsonOutput::writeJson(m_st);
            p->value["m_et"] = tars::JsonOutput::writeJson(m_et);
            p->value["m_fromUser"] = tars::JsonOutput::writeJson(m_fromUser);
            p->value["m_toUser"] = tars::JsonOutput::writeJson(m_toUser);
            p->value["m_toPhone"] = tars::JsonOutput::writeJson(m_toPhone);
            p->value["m_rpcCallId"] = tars::JsonOutput::writeJson(m_rpcCallId);
            p->value["m_sipCallId"] = tars::JsonOutput::writeJson(m_sipCallId);
            p->value["m_td"] = tars::JsonOutput::writeJson(m_td);
            p->value["m_type"] = tars::JsonOutput::writeJson(m_type);
            p->value["m_direction"] = tars::JsonOutput::writeJson(m_direction);
            p->value["m_confUri"] = tars::JsonOutput::writeJson(m_confUri);
            p->value["m_confMid"] = tars::JsonOutput::writeJson(m_confMid);
            p->value["m_cmt"] = tars::JsonOutput::writeJson(m_cmt);
            p->value["m_sipGatewayId"] = tars::JsonOutput::writeJson(m_sipGatewayId);
            p->value["m_sipProxyId"] = tars::JsonOutput::writeJson(m_sipProxyId);
            p->value["m_coreNetId"] = tars::JsonOutput::writeJson(m_coreNetId);
            p->value["m_errCode"] = tars::JsonOutput::writeJson(m_errCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_st,pObj->value["m_st"], true);
            tars::JsonInput::readJson(m_et,pObj->value["m_et"], true);
            tars::JsonInput::readJson(m_fromUser,pObj->value["m_fromUser"], true);
            tars::JsonInput::readJson(m_toUser,pObj->value["m_toUser"], true);
            tars::JsonInput::readJson(m_toPhone,pObj->value["m_toPhone"], true);
            tars::JsonInput::readJson(m_rpcCallId,pObj->value["m_rpcCallId"], true);
            tars::JsonInput::readJson(m_sipCallId,pObj->value["m_sipCallId"], true);
            tars::JsonInput::readJson(m_td,pObj->value["m_td"], true);
            tars::JsonInput::readJson(m_type,pObj->value["m_type"], true);
            tars::JsonInput::readJson(m_direction,pObj->value["m_direction"], true);
            tars::JsonInput::readJson(m_confUri,pObj->value["m_confUri"], true);
            tars::JsonInput::readJson(m_confMid,pObj->value["m_confMid"], true);
            tars::JsonInput::readJson(m_cmt,pObj->value["m_cmt"], true);
            tars::JsonInput::readJson(m_sipGatewayId,pObj->value["m_sipGatewayId"], true);
            tars::JsonInput::readJson(m_sipProxyId,pObj->value["m_sipProxyId"], true);
            tars::JsonInput::readJson(m_coreNetId,pObj->value["m_coreNetId"], true);
            tars::JsonInput::readJson(m_errCode,pObj->value["m_errCode"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_st,"m_st");
            _ds.display(m_et,"m_et");
            _ds.display(m_fromUser,"m_fromUser");
            _ds.display(m_toUser,"m_toUser");
            _ds.display(m_toPhone,"m_toPhone");
            _ds.display(m_rpcCallId,"m_rpcCallId");
            _ds.display(m_sipCallId,"m_sipCallId");
            _ds.display(m_td,"m_td");
            _ds.display(m_type,"m_type");
            _ds.display(m_direction,"m_direction");
            _ds.display(m_confUri,"m_confUri");
            _ds.display(m_confMid,"m_confMid");
            _ds.display(m_cmt,"m_cmt");
            _ds.display(m_sipGatewayId,"m_sipGatewayId");
            _ds.display(m_sipProxyId,"m_sipProxyId");
            _ds.display(m_coreNetId,"m_coreNetId");
            _ds.display(m_errCode,"m_errCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_st, true);
            _ds.displaySimple(m_et, true);
            _ds.displaySimple(m_fromUser, true);
            _ds.displaySimple(m_toUser, true);
            _ds.displaySimple(m_toPhone, true);
            _ds.displaySimple(m_rpcCallId, true);
            _ds.displaySimple(m_sipCallId, true);
            _ds.displaySimple(m_td, true);
            _ds.displaySimple(m_type, true);
            _ds.displaySimple(m_direction, true);
            _ds.displaySimple(m_confUri, true);
            _ds.displaySimple(m_confMid, true);
            _ds.displaySimple(m_cmt, true);
            _ds.displaySimple(m_sipGatewayId, true);
            _ds.displaySimple(m_sipProxyId, true);
            _ds.displaySimple(m_coreNetId, true);
            _ds.displaySimple(m_errCode, false);
            return _os;
        }
    public:
        tars::Int64 m_st;
        tars::Int64 m_et;
        std::string m_fromUser;
        std::string m_toUser;
        std::string m_toPhone;
        std::string m_rpcCallId;
        std::string m_sipCallId;
        tars::Int32 m_td;
        tars::Int32 m_type;
        tars::Int32 m_direction;
        std::string m_confUri;
        std::string m_confMid;
        tars::Int32 m_cmt;
        std::string m_sipGatewayId;
        std::string m_sipProxyId;
        std::string m_coreNetId;
        tars::Int32 m_errCode;
    };
    inline bool operator==(const SipCallRecord&l, const SipCallRecord&r)
    {
        return l.m_st == r.m_st && l.m_et == r.m_et && l.m_fromUser == r.m_fromUser && l.m_toUser == r.m_toUser && l.m_toPhone == r.m_toPhone && l.m_rpcCallId == r.m_rpcCallId && l.m_sipCallId == r.m_sipCallId && l.m_td == r.m_td && l.m_type == r.m_type && l.m_direction == r.m_direction && l.m_confUri == r.m_confUri && l.m_confMid == r.m_confMid && l.m_cmt == r.m_cmt && l.m_sipGatewayId == r.m_sipGatewayId && l.m_sipProxyId == r.m_sipProxyId && l.m_coreNetId == r.m_coreNetId && l.m_errCode == r.m_errCode;
    }
    inline bool operator!=(const SipCallRecord&l, const SipCallRecord&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipCallRecord&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipCallRecord&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CallRecord : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.CallRecord";
        }
        static string MD5()
        {
            return "fef3ec05ec9ce2304d181d5e375d16c6";
        }
        CallRecord()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_st = 0;
            m_est = 0;
            m_rt = 0;
            m_at = 0;
            m_et = 0;
            m_td = 0;
            m_rpcCallId = "";
            m_rtcCaller = "";
            m_rtcUserId = "";
            m_rtcCc = "";
            m_rtcIp = "";
            m_rtcCallee = "";
            m_rtcDisplay = "";
            m_cmt = 0;
            m_direction = 0;
            m_confUri = "";
            m_confMid = "";
            m_caller = "";
            m_callee = "";
            m_callerPrefix = "";
            m_calleePrefix = "";
            m_sipCallId = "";
            m_coreNetId = "";
            m_sbcIp = "";
            m_sbcPort = 0;
            m_sbcMediaIp = "";
            m_releaseType = 2;
            m_chargeNumber = "";
            m_sipGatewayId = "";
            m_sipProxyId = "";
            m_errCode = 0;
            m_errDesc = "";
            m_errCauseCode = 0;
            m_mediaErrCode = 0;
            m_mediaErrDesc = "";
            m_otherErrCode = 0;
            m_otherErrDesc = "";
            m_paramsExt = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (m_st != 0)
            {
                _os.write(m_st, 0);
            }
            if (m_est != 0)
            {
                _os.write(m_est, 1);
            }
            if (m_rt != 0)
            {
                _os.write(m_rt, 2);
            }
            if (m_at != 0)
            {
                _os.write(m_at, 3);
            }
            if (m_et != 0)
            {
                _os.write(m_et, 4);
            }
            if (m_td != 0)
            {
                _os.write(m_td, 5);
            }
            _os.write(m_rpcCallId, 6);
            _os.write(m_rtcCaller, 7);
            _os.write(m_rtcUserId, 8);
            _os.write(m_rtcCc, 9);
            _os.write(m_rtcIp, 10);
            _os.write(m_rtcCallee, 11);
            _os.write(m_rtcDisplay, 12);
            if (m_cmt != 0)
            {
                _os.write(m_cmt, 13);
            }
            if (m_direction != 0)
            {
                _os.write(m_direction, 14);
            }
            _os.write(m_confUri, 15);
            _os.write(m_confMid, 16);
            _os.write(m_caller, 17);
            _os.write(m_callee, 18);
            _os.write(m_callerPrefix, 19);
            _os.write(m_calleePrefix, 20);
            _os.write(m_sipCallId, 21);
            _os.write(m_coreNetId, 22);
            _os.write(m_sbcIp, 23);
            if (m_sbcPort != 0)
            {
                _os.write(m_sbcPort, 24);
            }
            _os.write(m_sbcMediaIp, 25);
            if (m_releaseType != 2)
            {
                _os.write(m_releaseType, 26);
            }
            _os.write(m_chargeNumber, 27);
            _os.write(m_sipGatewayId, 28);
            _os.write(m_sipProxyId, 29);
            if (m_errCode != 0)
            {
                _os.write(m_errCode, 30);
            }
            _os.write(m_errDesc, 31);
            if (m_errCauseCode != 0)
            {
                _os.write(m_errCauseCode, 32);
            }
            if (m_mediaErrCode != 0)
            {
                _os.write(m_mediaErrCode, 33);
            }
            _os.write(m_mediaErrDesc, 34);
            if (m_otherErrCode != 0)
            {
                _os.write(m_otherErrCode, 35);
            }
            _os.write(m_otherErrDesc, 36);
            _os.write(m_paramsExt, 37);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_st, 0, false);
            _is.read(m_est, 1, false);
            _is.read(m_rt, 2, false);
            _is.read(m_at, 3, false);
            _is.read(m_et, 4, false);
            _is.read(m_td, 5, false);
            _is.read(m_rpcCallId, 6, true);
            _is.read(m_rtcCaller, 7, true);
            _is.read(m_rtcUserId, 8, true);
            _is.read(m_rtcCc, 9, true);
            _is.read(m_rtcIp, 10, true);
            _is.read(m_rtcCallee, 11, true);
            _is.read(m_rtcDisplay, 12, true);
            _is.read(m_cmt, 13, false);
            _is.read(m_direction, 14, false);
            _is.read(m_confUri, 15, true);
            _is.read(m_confMid, 16, true);
            _is.read(m_caller, 17, true);
            _is.read(m_callee, 18, true);
            _is.read(m_callerPrefix, 19, true);
            _is.read(m_calleePrefix, 20, true);
            _is.read(m_sipCallId, 21, true);
            _is.read(m_coreNetId, 22, true);
            _is.read(m_sbcIp, 23, true);
            _is.read(m_sbcPort, 24, false);
            _is.read(m_sbcMediaIp, 25, true);
            _is.read(m_releaseType, 26, false);
            _is.read(m_chargeNumber, 27, true);
            _is.read(m_sipGatewayId, 28, true);
            _is.read(m_sipProxyId, 29, true);
            _is.read(m_errCode, 30, false);
            _is.read(m_errDesc, 31, true);
            _is.read(m_errCauseCode, 32, false);
            _is.read(m_mediaErrCode, 33, false);
            _is.read(m_mediaErrDesc, 34, true);
            _is.read(m_otherErrCode, 35, false);
            _is.read(m_otherErrDesc, 36, true);
            _is.read(m_paramsExt, 37, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_st"] = tars::JsonOutput::writeJson(m_st);
            p->value["m_est"] = tars::JsonOutput::writeJson(m_est);
            p->value["m_rt"] = tars::JsonOutput::writeJson(m_rt);
            p->value["m_at"] = tars::JsonOutput::writeJson(m_at);
            p->value["m_et"] = tars::JsonOutput::writeJson(m_et);
            p->value["m_td"] = tars::JsonOutput::writeJson(m_td);
            p->value["m_rpcCallId"] = tars::JsonOutput::writeJson(m_rpcCallId);
            p->value["m_rtcCaller"] = tars::JsonOutput::writeJson(m_rtcCaller);
            p->value["m_rtcUserId"] = tars::JsonOutput::writeJson(m_rtcUserId);
            p->value["m_rtcCc"] = tars::JsonOutput::writeJson(m_rtcCc);
            p->value["m_rtcIp"] = tars::JsonOutput::writeJson(m_rtcIp);
            p->value["m_rtcCallee"] = tars::JsonOutput::writeJson(m_rtcCallee);
            p->value["m_rtcDisplay"] = tars::JsonOutput::writeJson(m_rtcDisplay);
            p->value["m_cmt"] = tars::JsonOutput::writeJson(m_cmt);
            p->value["m_direction"] = tars::JsonOutput::writeJson(m_direction);
            p->value["m_confUri"] = tars::JsonOutput::writeJson(m_confUri);
            p->value["m_confMid"] = tars::JsonOutput::writeJson(m_confMid);
            p->value["m_caller"] = tars::JsonOutput::writeJson(m_caller);
            p->value["m_callee"] = tars::JsonOutput::writeJson(m_callee);
            p->value["m_callerPrefix"] = tars::JsonOutput::writeJson(m_callerPrefix);
            p->value["m_calleePrefix"] = tars::JsonOutput::writeJson(m_calleePrefix);
            p->value["m_sipCallId"] = tars::JsonOutput::writeJson(m_sipCallId);
            p->value["m_coreNetId"] = tars::JsonOutput::writeJson(m_coreNetId);
            p->value["m_sbcIp"] = tars::JsonOutput::writeJson(m_sbcIp);
            p->value["m_sbcPort"] = tars::JsonOutput::writeJson(m_sbcPort);
            p->value["m_sbcMediaIp"] = tars::JsonOutput::writeJson(m_sbcMediaIp);
            p->value["m_releaseType"] = tars::JsonOutput::writeJson(m_releaseType);
            p->value["m_chargeNumber"] = tars::JsonOutput::writeJson(m_chargeNumber);
            p->value["m_sipGatewayId"] = tars::JsonOutput::writeJson(m_sipGatewayId);
            p->value["m_sipProxyId"] = tars::JsonOutput::writeJson(m_sipProxyId);
            p->value["m_errCode"] = tars::JsonOutput::writeJson(m_errCode);
            p->value["m_errDesc"] = tars::JsonOutput::writeJson(m_errDesc);
            p->value["m_errCauseCode"] = tars::JsonOutput::writeJson(m_errCauseCode);
            p->value["m_mediaErrCode"] = tars::JsonOutput::writeJson(m_mediaErrCode);
            p->value["m_mediaErrDesc"] = tars::JsonOutput::writeJson(m_mediaErrDesc);
            p->value["m_otherErrCode"] = tars::JsonOutput::writeJson(m_otherErrCode);
            p->value["m_otherErrDesc"] = tars::JsonOutput::writeJson(m_otherErrDesc);
            p->value["m_paramsExt"] = tars::JsonOutput::writeJson(m_paramsExt);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_st,pObj->value["m_st"], false);
            tars::JsonInput::readJson(m_est,pObj->value["m_est"], false);
            tars::JsonInput::readJson(m_rt,pObj->value["m_rt"], false);
            tars::JsonInput::readJson(m_at,pObj->value["m_at"], false);
            tars::JsonInput::readJson(m_et,pObj->value["m_et"], false);
            tars::JsonInput::readJson(m_td,pObj->value["m_td"], false);
            tars::JsonInput::readJson(m_rpcCallId,pObj->value["m_rpcCallId"], true);
            tars::JsonInput::readJson(m_rtcCaller,pObj->value["m_rtcCaller"], true);
            tars::JsonInput::readJson(m_rtcUserId,pObj->value["m_rtcUserId"], true);
            tars::JsonInput::readJson(m_rtcCc,pObj->value["m_rtcCc"], true);
            tars::JsonInput::readJson(m_rtcIp,pObj->value["m_rtcIp"], true);
            tars::JsonInput::readJson(m_rtcCallee,pObj->value["m_rtcCallee"], true);
            tars::JsonInput::readJson(m_rtcDisplay,pObj->value["m_rtcDisplay"], true);
            tars::JsonInput::readJson(m_cmt,pObj->value["m_cmt"], false);
            tars::JsonInput::readJson(m_direction,pObj->value["m_direction"], false);
            tars::JsonInput::readJson(m_confUri,pObj->value["m_confUri"], true);
            tars::JsonInput::readJson(m_confMid,pObj->value["m_confMid"], true);
            tars::JsonInput::readJson(m_caller,pObj->value["m_caller"], true);
            tars::JsonInput::readJson(m_callee,pObj->value["m_callee"], true);
            tars::JsonInput::readJson(m_callerPrefix,pObj->value["m_callerPrefix"], true);
            tars::JsonInput::readJson(m_calleePrefix,pObj->value["m_calleePrefix"], true);
            tars::JsonInput::readJson(m_sipCallId,pObj->value["m_sipCallId"], true);
            tars::JsonInput::readJson(m_coreNetId,pObj->value["m_coreNetId"], true);
            tars::JsonInput::readJson(m_sbcIp,pObj->value["m_sbcIp"], true);
            tars::JsonInput::readJson(m_sbcPort,pObj->value["m_sbcPort"], false);
            tars::JsonInput::readJson(m_sbcMediaIp,pObj->value["m_sbcMediaIp"], true);
            tars::JsonInput::readJson(m_releaseType,pObj->value["m_releaseType"], false);
            tars::JsonInput::readJson(m_chargeNumber,pObj->value["m_chargeNumber"], true);
            tars::JsonInput::readJson(m_sipGatewayId,pObj->value["m_sipGatewayId"], true);
            tars::JsonInput::readJson(m_sipProxyId,pObj->value["m_sipProxyId"], true);
            tars::JsonInput::readJson(m_errCode,pObj->value["m_errCode"], false);
            tars::JsonInput::readJson(m_errDesc,pObj->value["m_errDesc"], true);
            tars::JsonInput::readJson(m_errCauseCode,pObj->value["m_errCauseCode"], false);
            tars::JsonInput::readJson(m_mediaErrCode,pObj->value["m_mediaErrCode"], false);
            tars::JsonInput::readJson(m_mediaErrDesc,pObj->value["m_mediaErrDesc"], true);
            tars::JsonInput::readJson(m_otherErrCode,pObj->value["m_otherErrCode"], false);
            tars::JsonInput::readJson(m_otherErrDesc,pObj->value["m_otherErrDesc"], true);
            tars::JsonInput::readJson(m_paramsExt,pObj->value["m_paramsExt"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_st,"m_st");
            _ds.display(m_est,"m_est");
            _ds.display(m_rt,"m_rt");
            _ds.display(m_at,"m_at");
            _ds.display(m_et,"m_et");
            _ds.display(m_td,"m_td");
            _ds.display(m_rpcCallId,"m_rpcCallId");
            _ds.display(m_rtcCaller,"m_rtcCaller");
            _ds.display(m_rtcUserId,"m_rtcUserId");
            _ds.display(m_rtcCc,"m_rtcCc");
            _ds.display(m_rtcIp,"m_rtcIp");
            _ds.display(m_rtcCallee,"m_rtcCallee");
            _ds.display(m_rtcDisplay,"m_rtcDisplay");
            _ds.display(m_cmt,"m_cmt");
            _ds.display(m_direction,"m_direction");
            _ds.display(m_confUri,"m_confUri");
            _ds.display(m_confMid,"m_confMid");
            _ds.display(m_caller,"m_caller");
            _ds.display(m_callee,"m_callee");
            _ds.display(m_callerPrefix,"m_callerPrefix");
            _ds.display(m_calleePrefix,"m_calleePrefix");
            _ds.display(m_sipCallId,"m_sipCallId");
            _ds.display(m_coreNetId,"m_coreNetId");
            _ds.display(m_sbcIp,"m_sbcIp");
            _ds.display(m_sbcPort,"m_sbcPort");
            _ds.display(m_sbcMediaIp,"m_sbcMediaIp");
            _ds.display(m_releaseType,"m_releaseType");
            _ds.display(m_chargeNumber,"m_chargeNumber");
            _ds.display(m_sipGatewayId,"m_sipGatewayId");
            _ds.display(m_sipProxyId,"m_sipProxyId");
            _ds.display(m_errCode,"m_errCode");
            _ds.display(m_errDesc,"m_errDesc");
            _ds.display(m_errCauseCode,"m_errCauseCode");
            _ds.display(m_mediaErrCode,"m_mediaErrCode");
            _ds.display(m_mediaErrDesc,"m_mediaErrDesc");
            _ds.display(m_otherErrCode,"m_otherErrCode");
            _ds.display(m_otherErrDesc,"m_otherErrDesc");
            _ds.display(m_paramsExt,"m_paramsExt");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_st, true);
            _ds.displaySimple(m_est, true);
            _ds.displaySimple(m_rt, true);
            _ds.displaySimple(m_at, true);
            _ds.displaySimple(m_et, true);
            _ds.displaySimple(m_td, true);
            _ds.displaySimple(m_rpcCallId, true);
            _ds.displaySimple(m_rtcCaller, true);
            _ds.displaySimple(m_rtcUserId, true);
            _ds.displaySimple(m_rtcCc, true);
            _ds.displaySimple(m_rtcIp, true);
            _ds.displaySimple(m_rtcCallee, true);
            _ds.displaySimple(m_rtcDisplay, true);
            _ds.displaySimple(m_cmt, true);
            _ds.displaySimple(m_direction, true);
            _ds.displaySimple(m_confUri, true);
            _ds.displaySimple(m_confMid, true);
            _ds.displaySimple(m_caller, true);
            _ds.displaySimple(m_callee, true);
            _ds.displaySimple(m_callerPrefix, true);
            _ds.displaySimple(m_calleePrefix, true);
            _ds.displaySimple(m_sipCallId, true);
            _ds.displaySimple(m_coreNetId, true);
            _ds.displaySimple(m_sbcIp, true);
            _ds.displaySimple(m_sbcPort, true);
            _ds.displaySimple(m_sbcMediaIp, true);
            _ds.displaySimple(m_releaseType, true);
            _ds.displaySimple(m_chargeNumber, true);
            _ds.displaySimple(m_sipGatewayId, true);
            _ds.displaySimple(m_sipProxyId, true);
            _ds.displaySimple(m_errCode, true);
            _ds.displaySimple(m_errDesc, true);
            _ds.displaySimple(m_errCauseCode, true);
            _ds.displaySimple(m_mediaErrCode, true);
            _ds.displaySimple(m_mediaErrDesc, true);
            _ds.displaySimple(m_otherErrCode, true);
            _ds.displaySimple(m_otherErrDesc, true);
            _ds.displaySimple(m_paramsExt, false);
            return _os;
        }
    public:
        tars::Int64 m_st;
        tars::Int64 m_est;
        tars::Int64 m_rt;
        tars::Int64 m_at;
        tars::Int64 m_et;
        tars::Int32 m_td;
        std::string m_rpcCallId;
        std::string m_rtcCaller;
        std::string m_rtcUserId;
        std::string m_rtcCc;
        std::string m_rtcIp;
        std::string m_rtcCallee;
        std::string m_rtcDisplay;
        tars::Int32 m_cmt;
        tars::Int32 m_direction;
        std::string m_confUri;
        std::string m_confMid;
        std::string m_caller;
        std::string m_callee;
        std::string m_callerPrefix;
        std::string m_calleePrefix;
        std::string m_sipCallId;
        std::string m_coreNetId;
        std::string m_sbcIp;
        tars::Int32 m_sbcPort;
        std::string m_sbcMediaIp;
        tars::Int32 m_releaseType;
        std::string m_chargeNumber;
        std::string m_sipGatewayId;
        std::string m_sipProxyId;
        tars::Int32 m_errCode;
        std::string m_errDesc;
        tars::Int32 m_errCauseCode;
        tars::Int32 m_mediaErrCode;
        std::string m_mediaErrDesc;
        tars::Int32 m_otherErrCode;
        std::string m_otherErrDesc;
        std::string m_paramsExt;
    };
    inline bool operator==(const CallRecord&l, const CallRecord&r)
    {
        return l.m_st == r.m_st && l.m_est == r.m_est && l.m_rt == r.m_rt && l.m_at == r.m_at && l.m_et == r.m_et && l.m_td == r.m_td && l.m_rpcCallId == r.m_rpcCallId && l.m_rtcCaller == r.m_rtcCaller && l.m_rtcUserId == r.m_rtcUserId && l.m_rtcCc == r.m_rtcCc && l.m_rtcIp == r.m_rtcIp && l.m_rtcCallee == r.m_rtcCallee && l.m_rtcDisplay == r.m_rtcDisplay && l.m_cmt == r.m_cmt && l.m_direction == r.m_direction && l.m_confUri == r.m_confUri && l.m_confMid == r.m_confMid && l.m_caller == r.m_caller && l.m_callee == r.m_callee && l.m_callerPrefix == r.m_callerPrefix && l.m_calleePrefix == r.m_calleePrefix && l.m_sipCallId == r.m_sipCallId && l.m_coreNetId == r.m_coreNetId && l.m_sbcIp == r.m_sbcIp && l.m_sbcPort == r.m_sbcPort && l.m_sbcMediaIp == r.m_sbcMediaIp && l.m_releaseType == r.m_releaseType && l.m_chargeNumber == r.m_chargeNumber && l.m_sipGatewayId == r.m_sipGatewayId && l.m_sipProxyId == r.m_sipProxyId && l.m_errCode == r.m_errCode && l.m_errDesc == r.m_errDesc && l.m_errCauseCode == r.m_errCauseCode && l.m_mediaErrCode == r.m_mediaErrCode && l.m_mediaErrDesc == r.m_mediaErrDesc && l.m_otherErrCode == r.m_otherErrCode && l.m_otherErrDesc == r.m_otherErrDesc && l.m_paramsExt == r.m_paramsExt;
    }
    inline bool operator!=(const CallRecord&l, const CallRecord&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CallRecord&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CallRecord&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipAccountRegInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipAccountRegInfo";
        }
        static string MD5()
        {
            return "e7abb5ea8e4abfff0153aeb3cbaa7c1a";
        }
        SipAccountRegInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_sipUri = "";
            m_accountId = "";
            m_iProxyed = 0;
            m_iPermitedProxy = 0;
            m_proxyName = "";
            m_proxyId = "";
            m_proxyedTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_sipUri, 0);
            _os.write(m_accountId, 1);
            _os.write(m_iProxyed, 2);
            _os.write(m_iPermitedProxy, 3);
            _os.write(m_proxyName, 4);
            _os.write(m_proxyId, 5);
            _os.write(m_proxyedTime, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_sipUri, 0, true);
            _is.read(m_accountId, 1, true);
            _is.read(m_iProxyed, 2, true);
            _is.read(m_iPermitedProxy, 3, true);
            _is.read(m_proxyName, 4, true);
            _is.read(m_proxyId, 5, true);
            _is.read(m_proxyedTime, 6, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_sipUri"] = tars::JsonOutput::writeJson(m_sipUri);
            p->value["m_accountId"] = tars::JsonOutput::writeJson(m_accountId);
            p->value["m_iProxyed"] = tars::JsonOutput::writeJson(m_iProxyed);
            p->value["m_iPermitedProxy"] = tars::JsonOutput::writeJson(m_iPermitedProxy);
            p->value["m_proxyName"] = tars::JsonOutput::writeJson(m_proxyName);
            p->value["m_proxyId"] = tars::JsonOutput::writeJson(m_proxyId);
            p->value["m_proxyedTime"] = tars::JsonOutput::writeJson(m_proxyedTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_sipUri,pObj->value["m_sipUri"], true);
            tars::JsonInput::readJson(m_accountId,pObj->value["m_accountId"], true);
            tars::JsonInput::readJson(m_iProxyed,pObj->value["m_iProxyed"], true);
            tars::JsonInput::readJson(m_iPermitedProxy,pObj->value["m_iPermitedProxy"], true);
            tars::JsonInput::readJson(m_proxyName,pObj->value["m_proxyName"], true);
            tars::JsonInput::readJson(m_proxyId,pObj->value["m_proxyId"], true);
            tars::JsonInput::readJson(m_proxyedTime,pObj->value["m_proxyedTime"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_sipUri,"m_sipUri");
            _ds.display(m_accountId,"m_accountId");
            _ds.display(m_iProxyed,"m_iProxyed");
            _ds.display(m_iPermitedProxy,"m_iPermitedProxy");
            _ds.display(m_proxyName,"m_proxyName");
            _ds.display(m_proxyId,"m_proxyId");
            _ds.display(m_proxyedTime,"m_proxyedTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_sipUri, true);
            _ds.displaySimple(m_accountId, true);
            _ds.displaySimple(m_iProxyed, true);
            _ds.displaySimple(m_iPermitedProxy, true);
            _ds.displaySimple(m_proxyName, true);
            _ds.displaySimple(m_proxyId, true);
            _ds.displaySimple(m_proxyedTime, false);
            return _os;
        }
    public:
        std::string m_sipUri;
        std::string m_accountId;
        tars::Int32 m_iProxyed;
        tars::Int32 m_iPermitedProxy;
        std::string m_proxyName;
        std::string m_proxyId;
        tars::Int64 m_proxyedTime;
    };
    inline bool operator==(const SipAccountRegInfo&l, const SipAccountRegInfo&r)
    {
        return l.m_sipUri == r.m_sipUri && l.m_accountId == r.m_accountId && l.m_iProxyed == r.m_iProxyed && l.m_iPermitedProxy == r.m_iPermitedProxy && l.m_proxyName == r.m_proxyName && l.m_proxyId == r.m_proxyId && l.m_proxyedTime == r.m_proxyedTime;
    }
    inline bool operator!=(const SipAccountRegInfo&l, const SipAccountRegInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipAccountRegInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipAccountRegInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RegStaus : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.RegStaus";
        }
        static string MD5()
        {
            return "3da3399bae7b655ca4d43a450f62c21d";
        }
        RegStaus()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_sipUri = "";
            m_proxyed = false;
            m_failedTimes = 0;
            m_time = 0;
            m_sipProxyId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_sipUri, 0);
            _os.write(m_proxyed, 1);
            _os.write(m_failedTimes, 2);
            _os.write(m_time, 3);
            _os.write(m_sipProxyId, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_sipUri, 0, true);
            _is.read(m_proxyed, 1, true);
            _is.read(m_failedTimes, 2, true);
            _is.read(m_time, 3, true);
            _is.read(m_sipProxyId, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_sipUri"] = tars::JsonOutput::writeJson(m_sipUri);
            p->value["m_proxyed"] = tars::JsonOutput::writeJson(m_proxyed);
            p->value["m_failedTimes"] = tars::JsonOutput::writeJson(m_failedTimes);
            p->value["m_time"] = tars::JsonOutput::writeJson(m_time);
            p->value["m_sipProxyId"] = tars::JsonOutput::writeJson(m_sipProxyId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_sipUri,pObj->value["m_sipUri"], true);
            tars::JsonInput::readJson(m_proxyed,pObj->value["m_proxyed"], true);
            tars::JsonInput::readJson(m_failedTimes,pObj->value["m_failedTimes"], true);
            tars::JsonInput::readJson(m_time,pObj->value["m_time"], true);
            tars::JsonInput::readJson(m_sipProxyId,pObj->value["m_sipProxyId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_sipUri,"m_sipUri");
            _ds.display(m_proxyed,"m_proxyed");
            _ds.display(m_failedTimes,"m_failedTimes");
            _ds.display(m_time,"m_time");
            _ds.display(m_sipProxyId,"m_sipProxyId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_sipUri, true);
            _ds.displaySimple(m_proxyed, true);
            _ds.displaySimple(m_failedTimes, true);
            _ds.displaySimple(m_time, true);
            _ds.displaySimple(m_sipProxyId, false);
            return _os;
        }
    public:
        std::string m_sipUri;
        tars::Bool m_proxyed;
        tars::Int32 m_failedTimes;
        tars::Int64 m_time;
        std::string m_sipProxyId;
    };
    inline bool operator==(const RegStaus&l, const RegStaus&r)
    {
        return l.m_sipUri == r.m_sipUri && l.m_proxyed == r.m_proxyed && l.m_failedTimes == r.m_failedTimes && l.m_time == r.m_time && l.m_sipProxyId == r.m_sipProxyId;
    }
    inline bool operator!=(const RegStaus&l, const RegStaus&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RegStaus&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RegStaus&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct RegStaus2 : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.RegStaus2";
        }
        static string MD5()
        {
            return "9b4151cf65bfd0e048d0d70790e0edd0";
        }
        RegStaus2()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_sipUri = "";
            m_proxyed = false;
            m_failedTimes = 0;
            m_iTmpReg = 0;
            m_time = 0;
            m_sipProxyId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_sipUri, 0);
            _os.write(m_proxyed, 1);
            _os.write(m_failedTimes, 2);
            _os.write(m_iTmpReg, 3);
            _os.write(m_time, 4);
            _os.write(m_sipProxyId, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_sipUri, 0, true);
            _is.read(m_proxyed, 1, true);
            _is.read(m_failedTimes, 2, true);
            _is.read(m_iTmpReg, 3, true);
            _is.read(m_time, 4, true);
            _is.read(m_sipProxyId, 5, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_sipUri"] = tars::JsonOutput::writeJson(m_sipUri);
            p->value["m_proxyed"] = tars::JsonOutput::writeJson(m_proxyed);
            p->value["m_failedTimes"] = tars::JsonOutput::writeJson(m_failedTimes);
            p->value["m_iTmpReg"] = tars::JsonOutput::writeJson(m_iTmpReg);
            p->value["m_time"] = tars::JsonOutput::writeJson(m_time);
            p->value["m_sipProxyId"] = tars::JsonOutput::writeJson(m_sipProxyId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_sipUri,pObj->value["m_sipUri"], true);
            tars::JsonInput::readJson(m_proxyed,pObj->value["m_proxyed"], true);
            tars::JsonInput::readJson(m_failedTimes,pObj->value["m_failedTimes"], true);
            tars::JsonInput::readJson(m_iTmpReg,pObj->value["m_iTmpReg"], true);
            tars::JsonInput::readJson(m_time,pObj->value["m_time"], true);
            tars::JsonInput::readJson(m_sipProxyId,pObj->value["m_sipProxyId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_sipUri,"m_sipUri");
            _ds.display(m_proxyed,"m_proxyed");
            _ds.display(m_failedTimes,"m_failedTimes");
            _ds.display(m_iTmpReg,"m_iTmpReg");
            _ds.display(m_time,"m_time");
            _ds.display(m_sipProxyId,"m_sipProxyId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_sipUri, true);
            _ds.displaySimple(m_proxyed, true);
            _ds.displaySimple(m_failedTimes, true);
            _ds.displaySimple(m_iTmpReg, true);
            _ds.displaySimple(m_time, true);
            _ds.displaySimple(m_sipProxyId, false);
            return _os;
        }
    public:
        std::string m_sipUri;
        tars::Bool m_proxyed;
        tars::Int32 m_failedTimes;
        tars::Int32 m_iTmpReg;
        tars::Int64 m_time;
        std::string m_sipProxyId;
    };
    inline bool operator==(const RegStaus2&l, const RegStaus2&r)
    {
        return l.m_sipUri == r.m_sipUri && l.m_proxyed == r.m_proxyed && l.m_failedTimes == r.m_failedTimes && l.m_iTmpReg == r.m_iTmpReg && l.m_time == r.m_time && l.m_sipProxyId == r.m_sipProxyId;
    }
    inline bool operator!=(const RegStaus2&l, const RegStaus2&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const RegStaus2&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,RegStaus2&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct NationCodeIp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.NationCodeIp";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        NationCodeIp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_nationCode = "";
            m_ip = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_nationCode, 0);
            _os.write(m_ip, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_nationCode, 0, true);
            _is.read(m_ip, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_nationCode"] = tars::JsonOutput::writeJson(m_nationCode);
            p->value["m_ip"] = tars::JsonOutput::writeJson(m_ip);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_nationCode,pObj->value["m_nationCode"], true);
            tars::JsonInput::readJson(m_ip,pObj->value["m_ip"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_nationCode,"m_nationCode");
            _ds.display(m_ip,"m_ip");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_nationCode, true);
            _ds.displaySimple(m_ip, false);
            return _os;
        }
    public:
        std::string m_nationCode;
        std::string m_ip;
    };
    inline bool operator==(const NationCodeIp&l, const NationCodeIp&r)
    {
        return l.m_nationCode == r.m_nationCode && l.m_ip == r.m_ip;
    }
    inline bool operator!=(const NationCodeIp&l, const NationCodeIp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NationCodeIp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NationCodeIp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CallSipPolicy : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.CallSipPolicy";
        }
        static string MD5()
        {
            return "bed05919c3d64eb43899b8d1fbfbd341";
        }
        CallSipPolicy()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_domainIdAppId = "";
            m_type = 0;
            m_value = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_domainIdAppId, 0);
            _os.write(m_type, 1);
            _os.write(m_value, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_domainIdAppId, 0, true);
            _is.read(m_type, 1, true);
            _is.read(m_value, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_domainIdAppId"] = tars::JsonOutput::writeJson(m_domainIdAppId);
            p->value["m_type"] = tars::JsonOutput::writeJson(m_type);
            p->value["m_value"] = tars::JsonOutput::writeJson(m_value);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_domainIdAppId,pObj->value["m_domainIdAppId"], true);
            tars::JsonInput::readJson(m_type,pObj->value["m_type"], true);
            tars::JsonInput::readJson(m_value,pObj->value["m_value"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_domainIdAppId,"m_domainIdAppId");
            _ds.display(m_type,"m_type");
            _ds.display(m_value,"m_value");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_domainIdAppId, true);
            _ds.displaySimple(m_type, true);
            _ds.displaySimple(m_value, false);
            return _os;
        }
    public:
        std::string m_domainIdAppId;
        tars::Int32 m_type;
        std::string m_value;
    };
    inline bool operator==(const CallSipPolicy&l, const CallSipPolicy&r)
    {
        return l.m_domainIdAppId == r.m_domainIdAppId && l.m_type == r.m_type && l.m_value == r.m_value;
    }
    inline bool operator!=(const CallSipPolicy&l, const CallSipPolicy&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CallSipPolicy&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CallSipPolicy&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CallSipPolicyOperation : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.CallSipPolicyOperation";
        }
        static string MD5()
        {
            return "980c60318826189318a8fb53e8552daf";
        }
        CallSipPolicyOperation()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_OpCategory = VoipApp::kOperationCategoryUnknown;
            m_policy.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)m_OpCategory, 0);
            _os.write(m_policy, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = VoipApp::kOperationCategoryUnknown;
            _is.read(eTemp0, 0, true);
            m_OpCategory = (VoipApp::OperationCategory)eTemp0;
            _is.read(m_policy, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_OpCategory"] = tars::JsonOutput::writeJson((tars::Int32)m_OpCategory);
            p->value["m_policy"] = tars::JsonOutput::writeJson(m_policy);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_OpCategory,pObj->value["m_OpCategory"], true);
            tars::JsonInput::readJson(m_policy,pObj->value["m_policy"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)m_OpCategory,"m_OpCategory");
            _ds.display(m_policy,"m_policy");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)m_OpCategory, true);
            _ds.displaySimple(m_policy, false);
            return _os;
        }
    public:
        VoipApp::OperationCategory m_OpCategory;
        VoipApp::CallSipPolicy m_policy;
    };
    inline bool operator==(const CallSipPolicyOperation&l, const CallSipPolicyOperation&r)
    {
        return l.m_OpCategory == r.m_OpCategory && l.m_policy == r.m_policy;
    }
    inline bool operator!=(const CallSipPolicyOperation&l, const CallSipPolicyOperation&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CallSipPolicyOperation&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CallSipPolicyOperation&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct AllowedIp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.AllowedIp";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        AllowedIp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_company = "";
            m_ip = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_company, 0);
            _os.write(m_ip, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_company, 0, true);
            _is.read(m_ip, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_company"] = tars::JsonOutput::writeJson(m_company);
            p->value["m_ip"] = tars::JsonOutput::writeJson(m_ip);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_company,pObj->value["m_company"], true);
            tars::JsonInput::readJson(m_ip,pObj->value["m_ip"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_company,"m_company");
            _ds.display(m_ip,"m_ip");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_company, true);
            _ds.displaySimple(m_ip, false);
            return _os;
        }
    public:
        std::string m_company;
        std::string m_ip;
    };
    inline bool operator==(const AllowedIp&l, const AllowedIp&r)
    {
        return l.m_company == r.m_company && l.m_ip == r.m_ip;
    }
    inline bool operator!=(const AllowedIp&l, const AllowedIp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const AllowedIp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,AllowedIp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SipGatewayDomainConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.SipGatewayDomainConfig";
        }
        static string MD5()
        {
            return "521b134839584223864dd6e99c930860";
        }
        SipGatewayDomainConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_strDomainId = "";
            m_strDomainName = "";
            m_strCloudIp = "";
            m_iChargeType = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_strDomainId, 0);
            _os.write(m_strDomainName, 1);
            _os.write(m_strCloudIp, 2);
            _os.write(m_iChargeType, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_strDomainId, 0, true);
            _is.read(m_strDomainName, 1, true);
            _is.read(m_strCloudIp, 2, true);
            _is.read(m_iChargeType, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_strDomainId"] = tars::JsonOutput::writeJson(m_strDomainId);
            p->value["m_strDomainName"] = tars::JsonOutput::writeJson(m_strDomainName);
            p->value["m_strCloudIp"] = tars::JsonOutput::writeJson(m_strCloudIp);
            p->value["m_iChargeType"] = tars::JsonOutput::writeJson(m_iChargeType);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_strDomainId,pObj->value["m_strDomainId"], true);
            tars::JsonInput::readJson(m_strDomainName,pObj->value["m_strDomainName"], true);
            tars::JsonInput::readJson(m_strCloudIp,pObj->value["m_strCloudIp"], true);
            tars::JsonInput::readJson(m_iChargeType,pObj->value["m_iChargeType"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_strDomainId,"m_strDomainId");
            _ds.display(m_strDomainName,"m_strDomainName");
            _ds.display(m_strCloudIp,"m_strCloudIp");
            _ds.display(m_iChargeType,"m_iChargeType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_strDomainId, true);
            _ds.displaySimple(m_strDomainName, true);
            _ds.displaySimple(m_strCloudIp, true);
            _ds.displaySimple(m_iChargeType, false);
            return _os;
        }
    public:
        std::string m_strDomainId;
        std::string m_strDomainName;
        std::string m_strCloudIp;
        tars::Int32 m_iChargeType;
    };
    inline bool operator==(const SipGatewayDomainConfig&l, const SipGatewayDomainConfig&r)
    {
        return l.m_strDomainId == r.m_strDomainId && l.m_strDomainName == r.m_strDomainName && l.m_strCloudIp == r.m_strCloudIp && l.m_iChargeType == r.m_iChargeType;
    }
    inline bool operator!=(const SipGatewayDomainConfig&l, const SipGatewayDomainConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SipGatewayDomainConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SipGatewayDomainConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct NumRouting : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.NumRouting";
        }
        static string MD5()
        {
            return "55420b345e13da84aad635417b0d3f4b";
        }
        NumRouting()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            m_domainIdAppId = "";
            m_callee = "";
            m_coreNetId = "";
            m_displayName = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(m_domainIdAppId, 0);
            _os.write(m_callee, 1);
            _os.write(m_coreNetId, 2);
            _os.write(m_displayName, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(m_domainIdAppId, 0, true);
            _is.read(m_callee, 1, true);
            _is.read(m_coreNetId, 2, true);
            _is.read(m_displayName, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["m_domainIdAppId"] = tars::JsonOutput::writeJson(m_domainIdAppId);
            p->value["m_callee"] = tars::JsonOutput::writeJson(m_callee);
            p->value["m_coreNetId"] = tars::JsonOutput::writeJson(m_coreNetId);
            p->value["m_displayName"] = tars::JsonOutput::writeJson(m_displayName);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(m_domainIdAppId,pObj->value["m_domainIdAppId"], true);
            tars::JsonInput::readJson(m_callee,pObj->value["m_callee"], true);
            tars::JsonInput::readJson(m_coreNetId,pObj->value["m_coreNetId"], true);
            tars::JsonInput::readJson(m_displayName,pObj->value["m_displayName"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(m_domainIdAppId,"m_domainIdAppId");
            _ds.display(m_callee,"m_callee");
            _ds.display(m_coreNetId,"m_coreNetId");
            _ds.display(m_displayName,"m_displayName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(m_domainIdAppId, true);
            _ds.displaySimple(m_callee, true);
            _ds.displaySimple(m_coreNetId, true);
            _ds.displaySimple(m_displayName, false);
            return _os;
        }
    public:
        std::string m_domainIdAppId;
        std::string m_callee;
        std::string m_coreNetId;
        std::string m_displayName;
    };
    inline bool operator==(const NumRouting&l, const NumRouting&r)
    {
        return l.m_domainIdAppId == r.m_domainIdAppId && l.m_callee == r.m_callee && l.m_coreNetId == r.m_coreNetId && l.m_displayName == r.m_displayName;
    }
    inline bool operator!=(const NumRouting&l, const NumRouting&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NumRouting&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NumRouting&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct DomainLineConfig : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.DomainLineConfig";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        DomainLineConfig()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            domainId = "";
            appId = "";
            coreNetId = "";
            sbcIp = "";
            sbcPort = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(domainId, 0);
            _os.write(appId, 1);
            _os.write(coreNetId, 2);
            _os.write(sbcIp, 3);
            _os.write(sbcPort, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(domainId, 0, true);
            _is.read(appId, 1, true);
            _is.read(coreNetId, 2, true);
            _is.read(sbcIp, 3, true);
            _is.read(sbcPort, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["domainId"] = tars::JsonOutput::writeJson(domainId);
            p->value["appId"] = tars::JsonOutput::writeJson(appId);
            p->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
            p->value["sbcIp"] = tars::JsonOutput::writeJson(sbcIp);
            p->value["sbcPort"] = tars::JsonOutput::writeJson(sbcPort);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(domainId,pObj->value["domainId"], true);
            tars::JsonInput::readJson(appId,pObj->value["appId"], true);
            tars::JsonInput::readJson(coreNetId,pObj->value["coreNetId"], true);
            tars::JsonInput::readJson(sbcIp,pObj->value["sbcIp"], true);
            tars::JsonInput::readJson(sbcPort,pObj->value["sbcPort"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(domainId,"domainId");
            _ds.display(appId,"appId");
            _ds.display(coreNetId,"coreNetId");
            _ds.display(sbcIp,"sbcIp");
            _ds.display(sbcPort,"sbcPort");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(domainId, true);
            _ds.displaySimple(appId, true);
            _ds.displaySimple(coreNetId, true);
            _ds.displaySimple(sbcIp, true);
            _ds.displaySimple(sbcPort, false);
            return _os;
        }
    public:
        std::string domainId;
        std::string appId;
        std::string coreNetId;
        std::string sbcIp;
        std::string sbcPort;
    };
    inline bool operator==(const DomainLineConfig&l, const DomainLineConfig&r)
    {
        return l.domainId == r.domainId && l.appId == r.appId && l.coreNetId == r.coreNetId && l.sbcIp == r.sbcIp && l.sbcPort == r.sbcPort;
    }
    inline bool operator!=(const DomainLineConfig&l, const DomainLineConfig&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const DomainLineConfig&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,DomainLineConfig&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class SipDbPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~SipDbPrxCallback(){}
        virtual void callback_GetAllAllowedIps(tars::Bool ret,  const vector<VoipApp::AllowedIp>& vectIps)
        { throw std::runtime_error("callback_GetAllAllowedIps() override incorrect."); }
        virtual void callback_GetAllAllowedIps_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetAllAllowedIps_exception() override incorrect."); }
        virtual void callback_GetAllAllowedIps(tars::Bool ret, vector<VoipApp::AllowedIp>&&  vectIps)
        { callback_GetAllAllowedIps(ret, vectIps); }

        virtual void callback_GetAllCallSipPolicys(tars::Bool ret,  const vector<VoipApp::CallSipPolicy>& policys)
        { throw std::runtime_error("callback_GetAllCallSipPolicys() override incorrect."); }
        virtual void callback_GetAllCallSipPolicys_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetAllCallSipPolicys_exception() override incorrect."); }
        virtual void callback_GetAllCallSipPolicys(tars::Bool ret, vector<VoipApp::CallSipPolicy>&&  policys)
        { callback_GetAllCallSipPolicys(ret, policys); }

        virtual void callback_GetAllNationCodeIps(tars::Bool ret,  const vector<VoipApp::NationCodeIp>& vectIps)
        { throw std::runtime_error("callback_GetAllNationCodeIps() override incorrect."); }
        virtual void callback_GetAllNationCodeIps_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetAllNationCodeIps_exception() override incorrect."); }
        virtual void callback_GetAllNationCodeIps(tars::Bool ret, vector<VoipApp::NationCodeIp>&&  vectIps)
        { callback_GetAllNationCodeIps(ret, vectIps); }

        virtual void callback_GetDomainAccessInfo(tars::Bool ret,  const vector<VoipApp::DomainAccessedConfig>& vectDomainAccessed,  const std::string& reason)
        { throw std::runtime_error("callback_GetDomainAccessInfo() override incorrect."); }
        virtual void callback_GetDomainAccessInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetDomainAccessInfo_exception() override incorrect."); }
        virtual void callback_GetDomainAccessInfo(tars::Bool ret, vector<VoipApp::DomainAccessedConfig>&&  vectDomainAccessed, std::string&&  reason)
        { callback_GetDomainAccessInfo(ret, vectDomainAccessed, reason); }

        virtual void callback_GetDomainAccessInfo2(tars::Bool ret,  const vector<VoipApp::DomainAccessedConfig2>& vectDomainAccessed,  const std::string& reason)
        { throw std::runtime_error("callback_GetDomainAccessInfo2() override incorrect."); }
        virtual void callback_GetDomainAccessInfo2_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetDomainAccessInfo2_exception() override incorrect."); }
        virtual void callback_GetDomainAccessInfo2(tars::Bool ret, vector<VoipApp::DomainAccessedConfig2>&&  vectDomainAccessed, std::string&&  reason)
        { callback_GetDomainAccessInfo2(ret, vectDomainAccessed, reason); }

        virtual void callback_GetRtpGatewayconfigInfo(tars::Bool ret,  const vector<VoipApp::RtpGatewayAccessedConfig>& rtpGatewayConfigLst)
        { throw std::runtime_error("callback_GetRtpGatewayconfigInfo() override incorrect."); }
        virtual void callback_GetRtpGatewayconfigInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetRtpGatewayconfigInfo_exception() override incorrect."); }
        virtual void callback_GetRtpGatewayconfigInfo(tars::Bool ret, vector<VoipApp::RtpGatewayAccessedConfig>&&  rtpGatewayConfigLst)
        { callback_GetRtpGatewayconfigInfo(ret, rtpGatewayConfigLst); }

        virtual void callback_GetSipProxyAccessCoreNetInfo(tars::Bool ret,  const vector<VoipApp::SipProxyAccessedCoreNetConfig>& vectSipProxyAccessedConfig,  const std::string& reason)
        { throw std::runtime_error("callback_GetSipProxyAccessCoreNetInfo() override incorrect."); }
        virtual void callback_GetSipProxyAccessCoreNetInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_GetSipProxyAccessCoreNetInfo_exception() override incorrect."); }
        virtual void callback_GetSipProxyAccessCoreNetInfo(tars::Bool ret, vector<VoipApp::SipProxyAccessedCoreNetConfig>&&  vectSipProxyAccessedConfig, std::string&&  reason)
        { callback_GetSipProxyAccessCoreNetInfo(ret, vectSipProxyAccessedConfig, reason); }

        virtual void callback_SetRtpGatewayAccessedId(tars::Bool ret,  const std::string& reason)
        { throw std::runtime_error("callback_SetRtpGatewayAccessedId() override incorrect."); }
        virtual void callback_SetRtpGatewayAccessedId_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_SetRtpGatewayAccessedId_exception() override incorrect."); }
        virtual void callback_SetRtpGatewayAccessedId(tars::Bool ret, std::string&&  reason)
        { callback_SetRtpGatewayAccessedId(ret, reason); }

        virtual void callback_SetSipProxyAccessedId(tars::Bool ret,  const std::string& reason)
        { throw std::runtime_error("callback_SetSipProxyAccessedId() override incorrect."); }
        virtual void callback_SetSipProxyAccessedId_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_SetSipProxyAccessedId_exception() override incorrect."); }
        virtual void callback_SetSipProxyAccessedId(tars::Bool ret, std::string&&  reason)
        { callback_SetSipProxyAccessedId(ret, reason); }

        virtual void callback_UpdateCallSipPolicys(tars::Bool ret)
        { throw std::runtime_error("callback_UpdateCallSipPolicys() override incorrect."); }
        virtual void callback_UpdateCallSipPolicys_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_UpdateCallSipPolicys_exception() override incorrect."); }

        virtual void callback_UpdateDomainAccessConfig(tars::Bool ret)
        { throw std::runtime_error("callback_UpdateDomainAccessConfig() override incorrect."); }
        virtual void callback_UpdateDomainAccessConfig_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_UpdateDomainAccessConfig_exception() override incorrect."); }

        virtual void callback_UpdateDomainAccessConfig2(tars::Bool ret)
        { throw std::runtime_error("callback_UpdateDomainAccessConfig2() override incorrect."); }
        virtual void callback_UpdateDomainAccessConfig2_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_UpdateDomainAccessConfig2_exception() override incorrect."); }

        virtual void callback_UpdateSipProxyAccessConfig(tars::Bool ret)
        { throw std::runtime_error("callback_UpdateSipProxyAccessConfig() override incorrect."); }
        virtual void callback_UpdateSipProxyAccessConfig_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_UpdateSipProxyAccessConfig_exception() override incorrect."); }

        virtual void callback_getDomainLineConfig(tars::Bool ret,  const vector<VoipApp::DomainLineConfig>& config,  const std::string& reason)
        { throw std::runtime_error("callback_getDomainLineConfig() override incorrect."); }
        virtual void callback_getDomainLineConfig_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getDomainLineConfig_exception() override incorrect."); }
        virtual void callback_getDomainLineConfig(tars::Bool ret, vector<VoipApp::DomainLineConfig>&&  config, std::string&&  reason)
        { callback_getDomainLineConfig(ret, config, reason); }

        virtual void callback_getNumberRouting(tars::Bool ret,  const std::string& displayName,  const std::string& coreNetId,  const std::string& reason)
        { throw std::runtime_error("callback_getNumberRouting() override incorrect."); }
        virtual void callback_getNumberRouting_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getNumberRouting_exception() override incorrect."); }
        virtual void callback_getNumberRouting(tars::Bool ret, std::string&&  displayName, std::string&&  coreNetId, std::string&&  reason)
        { callback_getNumberRouting(ret, displayName, coreNetId, reason); }

        virtual void callback_getSipCallRecordEx(tars::Bool ret,  const VoipApp::SipCallRecord& record)
        { throw std::runtime_error("callback_getSipCallRecordEx() override incorrect."); }
        virtual void callback_getSipCallRecordEx_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getSipCallRecordEx_exception() override incorrect."); }
        virtual void callback_getSipCallRecordEx(tars::Bool ret, VoipApp::SipCallRecord&&  record)
        { callback_getSipCallRecordEx(ret, record); }

        virtual void callback_insertCallRecords(tars::Bool ret)
        { throw std::runtime_error("callback_insertCallRecords() override incorrect."); }
        virtual void callback_insertCallRecords_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertCallRecords_exception() override incorrect."); }

        virtual void callback_insertNumberRouting(tars::Bool ret,  const std::string& reason)
        { throw std::runtime_error("callback_insertNumberRouting() override incorrect."); }
        virtual void callback_insertNumberRouting_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertNumberRouting_exception() override incorrect."); }
        virtual void callback_insertNumberRouting(tars::Bool ret, std::string&&  reason)
        { callback_insertNumberRouting(ret, reason); }

        virtual void callback_insertRecordsBatch(tars::Bool ret)
        { throw std::runtime_error("callback_insertRecordsBatch() override incorrect."); }
        virtual void callback_insertRecordsBatch_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_insertRecordsBatch_exception() override incorrect."); }

        virtual void callback_removeNumberRouting(tars::Bool ret,  const std::string& reason)
        { throw std::runtime_error("callback_removeNumberRouting() override incorrect."); }
        virtual void callback_removeNumberRouting_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_removeNumberRouting_exception() override incorrect."); }
        virtual void callback_removeNumberRouting(tars::Bool ret, std::string&&  reason)
        { callback_removeNumberRouting(ret, reason); }

        virtual void callback_updateDomainLineConfig(tars::Bool ret,  const std::string& reason)
        { throw std::runtime_error("callback_updateDomainLineConfig() override incorrect."); }
        virtual void callback_updateDomainLineConfig_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_updateDomainLineConfig_exception() override incorrect."); }
        virtual void callback_updateDomainLineConfig(tars::Bool ret, std::string&&  reason)
        { callback_updateDomainLineConfig(ret, reason); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipDb_all[]=
            {
                "GetAllAllowedIps",
                "GetAllCallSipPolicys",
                "GetAllNationCodeIps",
                "GetDomainAccessInfo",
                "GetDomainAccessInfo2",
                "GetRtpGatewayconfigInfo",
                "GetSipProxyAccessCoreNetInfo",
                "SetRtpGatewayAccessedId",
                "SetSipProxyAccessedId",
                "UpdateCallSipPolicys",
                "UpdateDomainAccessConfig",
                "UpdateDomainAccessConfig2",
                "UpdateSipProxyAccessConfig",
                "getDomainLineConfig",
                "getNumberRouting",
                "getSipCallRecordEx",
                "insertCallRecords",
                "insertNumberRouting",
                "insertRecordsBatch",
                "removeNumberRouting",
                "updateDomainLineConfig"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__SipDb_all, __SipDb_all+21, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipDb_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllAllowedIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::AllowedIp> vectIps;
                    _is.read(vectIps, 2, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetAllAllowedIps", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetAllAllowedIps(_ret, std::move(vectIps));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::CallSipPolicy> policys;
                    _is.read(policys, 2, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["policys"] = tars::JsonOutput::writeJson(policys);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetAllCallSipPolicys", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetAllCallSipPolicys(_ret, std::move(policys));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllNationCodeIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::NationCodeIp> vectIps;
                    _is.read(vectIps, 2, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetAllNationCodeIps", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetAllNationCodeIps(_ret, std::move(vectIps));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::DomainAccessedConfig> vectDomainAccessed;
                    _is.read(vectDomainAccessed, 2, true);
                    std::string reason;
                    _is.read(reason, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetDomainAccessInfo", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetDomainAccessInfo(_ret, std::move(vectDomainAccessed), std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::DomainAccessedConfig2> vectDomainAccessed;
                    _is.read(vectDomainAccessed, 2, true);
                    std::string reason;
                    _is.read(reason, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetDomainAccessInfo2", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetDomainAccessInfo2(_ret, std::move(vectDomainAccessed), std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::RtpGatewayAccessedConfig> rtpGatewayConfigLst;
                    _is.read(rtpGatewayConfigLst, 2, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetRtpGatewayconfigInfo(_ret, std::move(rtpGatewayConfigLst));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::SipProxyAccessedCoreNetConfig> vectSipProxyAccessedConfig;
                    _is.read(vectSipProxyAccessedConfig, 2, true);
                    std::string reason;
                    _is.read(reason, 3, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_GetSipProxyAccessCoreNetInfo(_ret, std::move(vectSipProxyAccessedConfig), std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetRtpGatewayAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string reason;
                    _is.read(reason, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_SetRtpGatewayAccessedId(_ret, std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetSipProxyAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string reason;
                    _is.read(reason, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "SetSipProxyAccessedId", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_SetSipProxyAccessedId(_ret, std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "UpdateCallSipPolicys", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_UpdateCallSipPolicys(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_UpdateDomainAccessConfig(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_UpdateDomainAccessConfig2(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_UpdateSipProxyAccessConfig(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    vector<VoipApp::DomainLineConfig> config;
                    _is.read(config, 3, true);
                    std::string reason;
                    _is.read(reason, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["config"] = tars::JsonOutput::writeJson(config);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getDomainLineConfig", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getDomainLineConfig(_ret, std::move(config), std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string displayName;
                    _is.read(displayName, 4, true);
                    std::string coreNetId;
                    _is.read(coreNetId, 5, true);
                    std::string reason;
                    _is.read(reason, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                            _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getNumberRouting", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getNumberRouting(_ret, std::move(displayName), std::move(coreNetId), std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSipCallRecordEx_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    VoipApp::SipCallRecord record;
                    _is.read(record, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["record"] = tars::JsonOutput::writeJson(record);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getSipCallRecordEx", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getSipCallRecordEx(_ret, std::move(record));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertCallRecords_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "insertCallRecords", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertCallRecords(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string reason;
                    _is.read(reason, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "insertNumberRouting", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertNumberRouting(_ret, std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertRecordsBatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "insertRecordsBatch", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_insertRecordsBatch(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_removeNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string reason;
                    _is.read(reason, 4, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "removeNumberRouting", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_removeNumberRouting(_ret, std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string reason;
                    _is.read(reason, 8, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "updateDomainLineConfig", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_updateDomainLineConfig(_ret, std::move(reason));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<SipDbPrxCallback> SipDbPrxCallbackPtr;

    //callback of promise async proxy for client
    class SipDbPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~SipDbPrxCallbackPromise(){}
    public:
        struct PromiseGetAllAllowedIps: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::AllowedIp> vectIps;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetAllAllowedIps > PromiseGetAllAllowedIpsPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr > &promise)
        : _promise_GetAllAllowedIps(promise)
        {}
        
        virtual void callback_GetAllAllowedIps(const SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr &ptr)
        {
            _promise_GetAllAllowedIps.setValue(ptr);
        }
        virtual void callback_GetAllAllowedIps_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetAllAllowedIps_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetAllAllowedIps.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr > _promise_GetAllAllowedIps;

    public:
        struct PromiseGetAllCallSipPolicys: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::CallSipPolicy> policys;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicys > PromiseGetAllCallSipPolicysPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr > &promise)
        : _promise_GetAllCallSipPolicys(promise)
        {}
        
        virtual void callback_GetAllCallSipPolicys(const SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr &ptr)
        {
            _promise_GetAllCallSipPolicys.setValue(ptr);
        }
        virtual void callback_GetAllCallSipPolicys_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetAllCallSipPolicys_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetAllCallSipPolicys.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr > _promise_GetAllCallSipPolicys;

    public:
        struct PromiseGetAllNationCodeIps: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::NationCodeIp> vectIps;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetAllNationCodeIps > PromiseGetAllNationCodeIpsPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr > &promise)
        : _promise_GetAllNationCodeIps(promise)
        {}
        
        virtual void callback_GetAllNationCodeIps(const SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr &ptr)
        {
            _promise_GetAllNationCodeIps.setValue(ptr);
        }
        virtual void callback_GetAllNationCodeIps_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetAllNationCodeIps_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetAllNationCodeIps.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr > _promise_GetAllNationCodeIps;

    public:
        struct PromiseGetDomainAccessInfo: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::DomainAccessedConfig> vectDomainAccessed;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo > PromiseGetDomainAccessInfoPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr > &promise)
        : _promise_GetDomainAccessInfo(promise)
        {}
        
        virtual void callback_GetDomainAccessInfo(const SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr &ptr)
        {
            _promise_GetDomainAccessInfo.setValue(ptr);
        }
        virtual void callback_GetDomainAccessInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetDomainAccessInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetDomainAccessInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr > _promise_GetDomainAccessInfo;

    public:
        struct PromiseGetDomainAccessInfo2: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::DomainAccessedConfig2> vectDomainAccessed;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2 > PromiseGetDomainAccessInfo2Ptr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr > &promise)
        : _promise_GetDomainAccessInfo2(promise)
        {}
        
        virtual void callback_GetDomainAccessInfo2(const SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr &ptr)
        {
            _promise_GetDomainAccessInfo2.setValue(ptr);
        }
        virtual void callback_GetDomainAccessInfo2_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetDomainAccessInfo2_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetDomainAccessInfo2.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr > _promise_GetDomainAccessInfo2;

    public:
        struct PromiseGetRtpGatewayconfigInfo: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::RtpGatewayAccessedConfig> rtpGatewayConfigLst;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfo > PromiseGetRtpGatewayconfigInfoPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr > &promise)
        : _promise_GetRtpGatewayconfigInfo(promise)
        {}
        
        virtual void callback_GetRtpGatewayconfigInfo(const SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr &ptr)
        {
            _promise_GetRtpGatewayconfigInfo.setValue(ptr);
        }
        virtual void callback_GetRtpGatewayconfigInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetRtpGatewayconfigInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetRtpGatewayconfigInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr > _promise_GetRtpGatewayconfigInfo;

    public:
        struct PromiseGetSipProxyAccessCoreNetInfo: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::SipProxyAccessedCoreNetConfig> vectSipProxyAccessedConfig;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfo > PromiseGetSipProxyAccessCoreNetInfoPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr > &promise)
        : _promise_GetSipProxyAccessCoreNetInfo(promise)
        {}
        
        virtual void callback_GetSipProxyAccessCoreNetInfo(const SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr &ptr)
        {
            _promise_GetSipProxyAccessCoreNetInfo.setValue(ptr);
        }
        virtual void callback_GetSipProxyAccessCoreNetInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:GetSipProxyAccessCoreNetInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_GetSipProxyAccessCoreNetInfo.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr > _promise_GetSipProxyAccessCoreNetInfo;

    public:
        struct PromiseSetRtpGatewayAccessedId: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedId > PromiseSetRtpGatewayAccessedIdPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr > &promise)
        : _promise_SetRtpGatewayAccessedId(promise)
        {}
        
        virtual void callback_SetRtpGatewayAccessedId(const SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr &ptr)
        {
            _promise_SetRtpGatewayAccessedId.setValue(ptr);
        }
        virtual void callback_SetRtpGatewayAccessedId_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:SetRtpGatewayAccessedId_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_SetRtpGatewayAccessedId.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr > _promise_SetRtpGatewayAccessedId;

    public:
        struct PromiseSetSipProxyAccessedId: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedId > PromiseSetSipProxyAccessedIdPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr > &promise)
        : _promise_SetSipProxyAccessedId(promise)
        {}
        
        virtual void callback_SetSipProxyAccessedId(const SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr &ptr)
        {
            _promise_SetSipProxyAccessedId.setValue(ptr);
        }
        virtual void callback_SetSipProxyAccessedId_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:SetSipProxyAccessedId_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_SetSipProxyAccessedId.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr > _promise_SetSipProxyAccessedId;

    public:
        struct PromiseUpdateCallSipPolicys: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicys > PromiseUpdateCallSipPolicysPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr > &promise)
        : _promise_UpdateCallSipPolicys(promise)
        {}
        
        virtual void callback_UpdateCallSipPolicys(const SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr &ptr)
        {
            _promise_UpdateCallSipPolicys.setValue(ptr);
        }
        virtual void callback_UpdateCallSipPolicys_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:UpdateCallSipPolicys_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_UpdateCallSipPolicys.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr > _promise_UpdateCallSipPolicys;

    public:
        struct PromiseUpdateDomainAccessConfig: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig > PromiseUpdateDomainAccessConfigPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr > &promise)
        : _promise_UpdateDomainAccessConfig(promise)
        {}
        
        virtual void callback_UpdateDomainAccessConfig(const SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr &ptr)
        {
            _promise_UpdateDomainAccessConfig.setValue(ptr);
        }
        virtual void callback_UpdateDomainAccessConfig_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:UpdateDomainAccessConfig_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_UpdateDomainAccessConfig.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr > _promise_UpdateDomainAccessConfig;

    public:
        struct PromiseUpdateDomainAccessConfig2: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2 > PromiseUpdateDomainAccessConfig2Ptr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr > &promise)
        : _promise_UpdateDomainAccessConfig2(promise)
        {}
        
        virtual void callback_UpdateDomainAccessConfig2(const SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr &ptr)
        {
            _promise_UpdateDomainAccessConfig2.setValue(ptr);
        }
        virtual void callback_UpdateDomainAccessConfig2_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:UpdateDomainAccessConfig2_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_UpdateDomainAccessConfig2.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr > _promise_UpdateDomainAccessConfig2;

    public:
        struct PromiseUpdateSipProxyAccessConfig: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfig > PromiseUpdateSipProxyAccessConfigPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr > &promise)
        : _promise_UpdateSipProxyAccessConfig(promise)
        {}
        
        virtual void callback_UpdateSipProxyAccessConfig(const SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr &ptr)
        {
            _promise_UpdateSipProxyAccessConfig.setValue(ptr);
        }
        virtual void callback_UpdateSipProxyAccessConfig_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:UpdateSipProxyAccessConfig_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_UpdateSipProxyAccessConfig.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr > _promise_UpdateSipProxyAccessConfig;

    public:
        struct PromisegetDomainLineConfig: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            vector<VoipApp::DomainLineConfig> config;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromisegetDomainLineConfig > PromisegetDomainLineConfigPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr > &promise)
        : _promise_getDomainLineConfig(promise)
        {}
        
        virtual void callback_getDomainLineConfig(const SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr &ptr)
        {
            _promise_getDomainLineConfig.setValue(ptr);
        }
        virtual void callback_getDomainLineConfig_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getDomainLineConfig_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getDomainLineConfig.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr > _promise_getDomainLineConfig;

    public:
        struct PromisegetNumberRouting: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string displayName;
            std::string coreNetId;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromisegetNumberRouting > PromisegetNumberRoutingPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr > &promise)
        : _promise_getNumberRouting(promise)
        {}
        
        virtual void callback_getNumberRouting(const SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr &ptr)
        {
            _promise_getNumberRouting.setValue(ptr);
        }
        virtual void callback_getNumberRouting_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getNumberRouting_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getNumberRouting.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr > _promise_getNumberRouting;

    public:
        struct PromisegetSipCallRecordEx: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            VoipApp::SipCallRecord record;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromisegetSipCallRecordEx > PromisegetSipCallRecordExPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr > &promise)
        : _promise_getSipCallRecordEx(promise)
        {}
        
        virtual void callback_getSipCallRecordEx(const SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr &ptr)
        {
            _promise_getSipCallRecordEx.setValue(ptr);
        }
        virtual void callback_getSipCallRecordEx_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getSipCallRecordEx_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getSipCallRecordEx.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr > _promise_getSipCallRecordEx;

    public:
        struct PromiseinsertCallRecords: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseinsertCallRecords > PromiseinsertCallRecordsPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr > &promise)
        : _promise_insertCallRecords(promise)
        {}
        
        virtual void callback_insertCallRecords(const SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr &ptr)
        {
            _promise_insertCallRecords.setValue(ptr);
        }
        virtual void callback_insertCallRecords_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertCallRecords_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertCallRecords.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr > _promise_insertCallRecords;

    public:
        struct PromiseinsertNumberRouting: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseinsertNumberRouting > PromiseinsertNumberRoutingPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr > &promise)
        : _promise_insertNumberRouting(promise)
        {}
        
        virtual void callback_insertNumberRouting(const SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr &ptr)
        {
            _promise_insertNumberRouting.setValue(ptr);
        }
        virtual void callback_insertNumberRouting_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertNumberRouting_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertNumberRouting.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr > _promise_insertNumberRouting;

    public:
        struct PromiseinsertRecordsBatch: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseinsertRecordsBatch > PromiseinsertRecordsBatchPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr > &promise)
        : _promise_insertRecordsBatch(promise)
        {}
        
        virtual void callback_insertRecordsBatch(const SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr &ptr)
        {
            _promise_insertRecordsBatch.setValue(ptr);
        }
        virtual void callback_insertRecordsBatch_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:insertRecordsBatch_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_insertRecordsBatch.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr > _promise_insertRecordsBatch;

    public:
        struct PromiseremoveNumberRouting: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseremoveNumberRouting > PromiseremoveNumberRoutingPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr > &promise)
        : _promise_removeNumberRouting(promise)
        {}
        
        virtual void callback_removeNumberRouting(const SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr &ptr)
        {
            _promise_removeNumberRouting.setValue(ptr);
        }
        virtual void callback_removeNumberRouting_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:removeNumberRouting_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_removeNumberRouting.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr > _promise_removeNumberRouting;

    public:
        struct PromiseupdateDomainLineConfig: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string reason;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipDbPrxCallbackPromise::PromiseupdateDomainLineConfig > PromiseupdateDomainLineConfigPtr;

        SipDbPrxCallbackPromise(const tars::Promise< SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr > &promise)
        : _promise_updateDomainLineConfig(promise)
        {}
        
        virtual void callback_updateDomainLineConfig(const SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr &ptr)
        {
            _promise_updateDomainLineConfig.setValue(ptr);
        }
        virtual void callback_updateDomainLineConfig_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:updateDomainLineConfig_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_updateDomainLineConfig.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr > _promise_updateDomainLineConfig;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipDb_all[]=
            {
                "GetAllAllowedIps",
                "GetAllCallSipPolicys",
                "GetAllNationCodeIps",
                "GetDomainAccessInfo",
                "GetDomainAccessInfo2",
                "GetRtpGatewayconfigInfo",
                "GetSipProxyAccessCoreNetInfo",
                "SetRtpGatewayAccessedId",
                "SetSipProxyAccessedId",
                "UpdateCallSipPolicys",
                "UpdateDomainAccessConfig",
                "UpdateDomainAccessConfig2",
                "UpdateSipProxyAccessConfig",
                "getDomainLineConfig",
                "getNumberRouting",
                "getSipCallRecordEx",
                "insertCallRecords",
                "insertNumberRouting",
                "insertRecordsBatch",
                "removeNumberRouting",
                "updateDomainLineConfig"
            };

            pair<string*, string*> r = equal_range(__SipDb_all, __SipDb_all+21, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipDb_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllAllowedIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr ptr (new SipDbPrxCallbackPromise::PromiseGetAllAllowedIps());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vectIps, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllAllowedIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllAllowedIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetAllAllowedIps(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr ptr (new SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicys());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->policys, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetAllCallSipPolicys(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllNationCodeIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr ptr (new SipDbPrxCallbackPromise::PromiseGetAllNationCodeIps());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vectIps, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllNationCodeIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllNationCodeIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetAllNationCodeIps(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr ptr (new SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vectDomainAccessed, 2, true);
                        _is.read(ptr->reason, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetDomainAccessInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetDomainAccessInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetDomainAccessInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr ptr (new SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vectDomainAccessed, 2, true);
                        _is.read(ptr->reason, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetDomainAccessInfo2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetDomainAccessInfo2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetDomainAccessInfo2(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr ptr (new SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfo());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->rtpGatewayConfigLst, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetRtpGatewayconfigInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr ptr (new SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfo());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vectSipProxyAccessedConfig, 2, true);
                        _is.read(ptr->reason, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_GetSipProxyAccessCoreNetInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetRtpGatewayAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr ptr (new SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedId());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->reason, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_SetRtpGatewayAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_SetRtpGatewayAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_SetRtpGatewayAccessedId(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetSipProxyAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr ptr (new SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedId());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->reason, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_SetSipProxyAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_SetSipProxyAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_SetSipProxyAccessedId(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr ptr (new SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicys());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_UpdateCallSipPolicys(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr ptr (new SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateDomainAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateDomainAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_UpdateDomainAccessConfig(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr ptr (new SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateDomainAccessConfig2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateDomainAccessConfig2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_UpdateDomainAccessConfig2(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr ptr (new SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfig());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_UpdateSipProxyAccessConfig(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr ptr (new SipDbPrxCallbackPromise::PromisegetDomainLineConfig());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->config, 3, true);
                        _is.read(ptr->reason, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getDomainLineConfig(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr ptr (new SipDbPrxCallbackPromise::PromisegetNumberRouting());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->displayName, 4, true);
                        _is.read(ptr->coreNetId, 5, true);
                        _is.read(ptr->reason, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getNumberRouting(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSipCallRecordEx_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr ptr (new SipDbPrxCallbackPromise::PromisegetSipCallRecordEx());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->record, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getSipCallRecordEx_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSipCallRecordEx_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getSipCallRecordEx(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertCallRecords_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr ptr (new SipDbPrxCallbackPromise::PromiseinsertCallRecords());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertCallRecords_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertCallRecords_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertCallRecords(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr ptr (new SipDbPrxCallbackPromise::PromiseinsertNumberRouting());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->reason, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_insertNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertNumberRouting(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertRecordsBatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr ptr (new SipDbPrxCallbackPromise::PromiseinsertRecordsBatch());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertRecordsBatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertRecordsBatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_insertRecordsBatch(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_removeNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr ptr (new SipDbPrxCallbackPromise::PromiseremoveNumberRouting());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->reason, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_removeNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_removeNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_removeNumberRouting(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr ptr (new SipDbPrxCallbackPromise::PromiseupdateDomainLineConfig());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->reason, 8, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_updateDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_updateDomainLineConfig(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<SipDbPrxCallbackPromise> SipDbPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class SipDbCoroPrxCallback: public SipDbPrxCallback
    {
    public:
        virtual ~SipDbCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipDb_all[]=
            {
                "GetAllAllowedIps",
                "GetAllCallSipPolicys",
                "GetAllNationCodeIps",
                "GetDomainAccessInfo",
                "GetDomainAccessInfo2",
                "GetRtpGatewayconfigInfo",
                "GetSipProxyAccessCoreNetInfo",
                "SetRtpGatewayAccessedId",
                "SetSipProxyAccessedId",
                "UpdateCallSipPolicys",
                "UpdateDomainAccessConfig",
                "UpdateDomainAccessConfig2",
                "UpdateSipProxyAccessConfig",
                "getDomainLineConfig",
                "getNumberRouting",
                "getSipCallRecordEx",
                "insertCallRecords",
                "insertNumberRouting",
                "insertRecordsBatch",
                "removeNumberRouting",
                "updateDomainLineConfig"
            };

            pair<string*, string*> r = equal_range(__SipDb_all, __SipDb_all+21, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipDb_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllAllowedIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::AllowedIp> vectIps;
                        _is.read(vectIps, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetAllAllowedIps(_ret, std::move(vectIps));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllAllowedIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllAllowedIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::CallSipPolicy> policys;
                        _is.read(policys, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetAllCallSipPolicys(_ret, std::move(policys));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetAllNationCodeIps_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::NationCodeIp> vectIps;
                        _is.read(vectIps, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetAllNationCodeIps(_ret, std::move(vectIps));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetAllNationCodeIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetAllNationCodeIps_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::DomainAccessedConfig> vectDomainAccessed;
                        _is.read(vectDomainAccessed, 2, true);
                        std::string reason;
                        _is.read(reason, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetDomainAccessInfo(_ret, std::move(vectDomainAccessed), std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetDomainAccessInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetDomainAccessInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetDomainAccessInfo2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::DomainAccessedConfig2> vectDomainAccessed;
                        _is.read(vectDomainAccessed, 2, true);
                        std::string reason;
                        _is.read(reason, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetDomainAccessInfo2(_ret, std::move(vectDomainAccessed), std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetDomainAccessInfo2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetDomainAccessInfo2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::RtpGatewayAccessedConfig> rtpGatewayConfigLst;
                        _is.read(rtpGatewayConfigLst, 2, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetRtpGatewayconfigInfo(_ret, std::move(rtpGatewayConfigLst));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetRtpGatewayconfigInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::SipProxyAccessedCoreNetConfig> vectSipProxyAccessedConfig;
                        _is.read(vectSipProxyAccessedConfig, 2, true);
                        std::string reason;
                        _is.read(reason, 3, true);
                        setResponseContext(_msg_->response->context);

                        callback_GetSipProxyAccessCoreNetInfo(_ret, std::move(vectSipProxyAccessedConfig), std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_GetSipProxyAccessCoreNetInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetRtpGatewayAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string reason;
                        _is.read(reason, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_SetRtpGatewayAccessedId(_ret, std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_SetRtpGatewayAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_SetRtpGatewayAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_SetSipProxyAccessedId_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string reason;
                        _is.read(reason, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_SetSipProxyAccessedId(_ret, std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_SetSipProxyAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_SetSipProxyAccessedId_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateCallSipPolicys_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_UpdateCallSipPolicys(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateCallSipPolicys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_UpdateDomainAccessConfig(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateDomainAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateDomainAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateDomainAccessConfig2_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_UpdateDomainAccessConfig2(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateDomainAccessConfig2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateDomainAccessConfig2_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_UpdateSipProxyAccessConfig(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_UpdateSipProxyAccessConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        vector<VoipApp::DomainLineConfig> config;
                        _is.read(config, 3, true);
                        std::string reason;
                        _is.read(reason, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getDomainLineConfig(_ret, std::move(config), std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string displayName;
                        _is.read(displayName, 4, true);
                        std::string coreNetId;
                        _is.read(coreNetId, 5, true);
                        std::string reason;
                        _is.read(reason, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_getNumberRouting(_ret, std::move(displayName), std::move(coreNetId), std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSipCallRecordEx_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        VoipApp::SipCallRecord record;
                        _is.read(record, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_getSipCallRecordEx(_ret, std::move(record));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getSipCallRecordEx_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSipCallRecordEx_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertCallRecords_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertCallRecords(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertCallRecords_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertCallRecords_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string reason;
                        _is.read(reason, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_insertNumberRouting(_ret, std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_insertRecordsBatch_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        setResponseContext(_msg_->response->context);

                        callback_insertRecordsBatch(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_insertRecordsBatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_insertRecordsBatch_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_removeNumberRouting_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string reason;
                        _is.read(reason, 4, true);
                        setResponseContext(_msg_->response->context);

                        callback_removeNumberRouting(_ret, std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_removeNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_removeNumberRouting_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_updateDomainLineConfig_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string reason;
                        _is.read(reason, 8, true);
                        setResponseContext(_msg_->response->context);

                        callback_updateDomainLineConfig(_ret, std::move(reason));

                    }
                    catch(std::exception &ex)
                    {
                        callback_updateDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_updateDomainLineConfig_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<SipDbCoroPrxCallback> SipDbCoroPrxCallbackPtr;

    /* proxy for client */
    class SipDbProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Bool GetAllAllowedIps(const std::string & tableName,vector<VoipApp::AllowedIp> &vectIps,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(vectIps, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllAllowedIps", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetAllAllowedIps", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(vectIps, 2, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetAllAllowedIps", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetAllAllowedIps(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllAllowedIps", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetAllAllowedIps", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr > promise_async_GetAllAllowedIps(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllAllowedIpsPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllAllowedIps", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetAllAllowedIps(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllAllowedIps", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetAllCallSipPolicys(const std::string & tableName,vector<VoipApp::CallSipPolicy> &policys,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(policys, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllCallSipPolicys", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetAllCallSipPolicys", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(policys, 2, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["policys"] = tars::JsonOutput::writeJson(policys);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetAllCallSipPolicys", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetAllCallSipPolicys(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllCallSipPolicys", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetAllCallSipPolicys", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr > promise_async_GetAllCallSipPolicys(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllCallSipPolicysPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllCallSipPolicys", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetAllCallSipPolicys(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllCallSipPolicys", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetAllNationCodeIps(const std::string & tableName,vector<VoipApp::NationCodeIp> &vectIps,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(vectIps, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllNationCodeIps", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetAllNationCodeIps", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(vectIps, 2, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetAllNationCodeIps", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetAllNationCodeIps(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetAllNationCodeIps", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetAllNationCodeIps", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr > promise_async_GetAllNationCodeIps(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetAllNationCodeIpsPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllNationCodeIps", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetAllNationCodeIps(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetAllNationCodeIps", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetDomainAccessInfo(const std::string & tableName,vector<VoipApp::DomainAccessedConfig> &vectDomainAccessed,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(vectDomainAccessed, 2);
            _os.write(reason, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetDomainAccessInfo", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetDomainAccessInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(vectDomainAccessed, 2, true);
            _is.read(reason, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetDomainAccessInfo", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetDomainAccessInfo(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetDomainAccessInfo", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr > promise_async_GetDomainAccessInfo(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfoPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetDomainAccessInfo(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetDomainAccessInfo2(const std::string & tableName,vector<VoipApp::DomainAccessedConfig2> &vectDomainAccessed,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(vectDomainAccessed, 2);
            _os.write(reason, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetDomainAccessInfo2", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetDomainAccessInfo2", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(vectDomainAccessed, 2, true);
            _is.read(reason, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetDomainAccessInfo2", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetDomainAccessInfo2(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetDomainAccessInfo2", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo2", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr > promise_async_GetDomainAccessInfo2(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetDomainAccessInfo2Ptr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo2", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetDomainAccessInfo2(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetDomainAccessInfo2", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetRtpGatewayconfigInfo(const std::string & tableName,vector<VoipApp::RtpGatewayAccessedConfig> &rtpGatewayConfigLst,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(rtpGatewayConfigLst, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetRtpGatewayconfigInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(rtpGatewayConfigLst, 2, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetRtpGatewayconfigInfo(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetRtpGatewayconfigInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr > promise_async_GetRtpGatewayconfigInfo(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetRtpGatewayconfigInfoPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetRtpGatewayconfigInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetRtpGatewayconfigInfo(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetRtpGatewayconfigInfo", _os, context, _mStatus, callback, true);
        }

        tars::Bool GetSipProxyAccessCoreNetInfo(const std::string & tableName,vector<VoipApp::SipProxyAccessedCoreNetConfig> &vectSipProxyAccessedConfig,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(vectSipProxyAccessedConfig, 2);
            _os.write(reason, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"GetSipProxyAccessCoreNetInfo", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(vectSipProxyAccessedConfig, 2, true);
            _is.read(reason, 3, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_GetSipProxyAccessCoreNetInfo(SipDbPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"GetSipProxyAccessCoreNetInfo", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr > promise_async_GetSipProxyAccessCoreNetInfo(const std::string &tableName,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseGetSipProxyAccessCoreNetInfoPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetSipProxyAccessCoreNetInfo", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_GetSipProxyAccessCoreNetInfo(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"GetSipProxyAccessCoreNetInfo", _os, context, _mStatus, callback, true);
        }

        tars::Bool SetRtpGatewayAccessedId(const std::string & tableName,const std::string & rtpGatewayName,const std::string & rtpGatewayId,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(rtpGatewayName, 2);
            _os.write(rtpGatewayId, 3);
            _os.write(reason, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["rtpGatewayName"] = tars::JsonOutput::writeJson(rtpGatewayName);
                    _p_->value["rtpGatewayId"] = tars::JsonOutput::writeJson(rtpGatewayId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"SetRtpGatewayAccessedId", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(reason, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_SetRtpGatewayAccessedId(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &rtpGatewayName,const std::string &rtpGatewayId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(rtpGatewayName, 2);
            _os.write(rtpGatewayId, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["rtpGatewayName"] = tars::JsonOutput::writeJson(rtpGatewayName);
                    _p_->value["rtpGatewayId"] = tars::JsonOutput::writeJson(rtpGatewayId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"SetRtpGatewayAccessedId", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr > promise_async_SetRtpGatewayAccessedId(const std::string &tableName,const std::string &rtpGatewayName,const std::string &rtpGatewayId,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseSetRtpGatewayAccessedIdPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(rtpGatewayName, 2);
            _os.write(rtpGatewayId, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"SetRtpGatewayAccessedId", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_SetRtpGatewayAccessedId(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &rtpGatewayName,const std::string &rtpGatewayId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(rtpGatewayName, 2);
            _os.write(rtpGatewayId, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"SetRtpGatewayAccessedId", _os, context, _mStatus, callback, true);
        }

        tars::Bool SetSipProxyAccessedId(const std::string & tableName,const std::string & sipProxyName,const std::string & sipProxyid,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(sipProxyName, 2);
            _os.write(sipProxyid, 3);
            _os.write(reason, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["sipProxyName"] = tars::JsonOutput::writeJson(sipProxyName);
                    _p_->value["sipProxyid"] = tars::JsonOutput::writeJson(sipProxyid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "SetSipProxyAccessedId", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"SetSipProxyAccessedId", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(reason, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "SetSipProxyAccessedId", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_SetSipProxyAccessedId(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &sipProxyName,const std::string &sipProxyid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(sipProxyName, 2);
            _os.write(sipProxyid, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["sipProxyName"] = tars::JsonOutput::writeJson(sipProxyName);
                    _p_->value["sipProxyid"] = tars::JsonOutput::writeJson(sipProxyid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "SetSipProxyAccessedId", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"SetSipProxyAccessedId", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr > promise_async_SetSipProxyAccessedId(const std::string &tableName,const std::string &sipProxyName,const std::string &sipProxyid,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseSetSipProxyAccessedIdPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(sipProxyName, 2);
            _os.write(sipProxyid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"SetSipProxyAccessedId", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_SetSipProxyAccessedId(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &sipProxyName,const std::string &sipProxyid,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(sipProxyName, 2);
            _os.write(sipProxyid, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"SetSipProxyAccessedId", _os, context, _mStatus, callback, true);
        }

        tars::Bool UpdateCallSipPolicys(const std::string & tableName,const vector<VoipApp::CallSipPolicyOperation> & OpSequence,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateCallSipPolicys", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"UpdateCallSipPolicys", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "UpdateCallSipPolicys", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_UpdateCallSipPolicys(SipDbPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::CallSipPolicyOperation> &OpSequence,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateCallSipPolicys", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"UpdateCallSipPolicys", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr > promise_async_UpdateCallSipPolicys(const std::string &tableName,const vector<VoipApp::CallSipPolicyOperation> &OpSequence,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateCallSipPolicysPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateCallSipPolicys", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_UpdateCallSipPolicys(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::CallSipPolicyOperation> &OpSequence,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateCallSipPolicys", _os, context, _mStatus, callback, true);
        }

        tars::Bool UpdateDomainAccessConfig(const std::string & tableName,const vector<VoipApp::DomainAccessConfigOperation> & OpSequence,tars::Int64 insertedTime,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"UpdateDomainAccessConfig", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_UpdateDomainAccessConfig(SipDbPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr > promise_async_UpdateDomainAccessConfig(const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfigPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_UpdateDomainAccessConfig(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig", _os, context, _mStatus, callback, true);
        }

        tars::Bool UpdateDomainAccessConfig2(const std::string & tableName,const vector<VoipApp::DomainAccessConfigOperation2> & OpSequence,tars::Int64 insertedTime,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"UpdateDomainAccessConfig2", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_UpdateDomainAccessConfig2(SipDbPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation2> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig2", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr > promise_async_UpdateDomainAccessConfig2(const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation2> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateDomainAccessConfig2Ptr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig2", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_UpdateDomainAccessConfig2(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::DomainAccessConfigOperation2> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateDomainAccessConfig2", _os, context, _mStatus, callback, true);
        }

        tars::Bool UpdateSipProxyAccessConfig(const std::string & tableName,const vector<VoipApp::SipProxyConfigOperation> & OpSequence,tars::Int64 insertedTime,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"UpdateSipProxyAccessConfig", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_UpdateSipProxyAccessConfig(SipDbPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::SipProxyConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                    _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"UpdateSipProxyAccessConfig", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr > promise_async_UpdateSipProxyAccessConfig(const std::string &tableName,const vector<VoipApp::SipProxyConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseUpdateSipProxyAccessConfigPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateSipProxyAccessConfig", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_UpdateSipProxyAccessConfig(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const vector<VoipApp::SipProxyConfigOperation> &OpSequence,tars::Int64 insertedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(OpSequence, 2);
            _os.write(insertedTime, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"UpdateSipProxyAccessConfig", _os, context, _mStatus, callback, true);
        }

        tars::Bool getDomainLineConfig(const std::string & domainId,const std::string & appId,vector<VoipApp::DomainLineConfig> &config,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(config, 3);
            _os.write(reason, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getDomainLineConfig", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getDomainLineConfig", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(config, 3, true);
            _is.read(reason, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["config"] = tars::JsonOutput::writeJson(config);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getDomainLineConfig", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getDomainLineConfig(SipDbPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getDomainLineConfig", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getDomainLineConfig", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr > promise_async_getDomainLineConfig(const std::string &domainId,const std::string &appId,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromisegetDomainLineConfigPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getDomainLineConfig", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getDomainLineConfig(SipDbCoroPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getDomainLineConfig", _os, context, _mStatus, callback, true);
        }

        tars::Bool getNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const std::string & callee,std::string &displayName,std::string &coreNetId,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(callee, 3);
            _os.write(displayName, 4);
            _os.write(coreNetId, 5);
            _os.write(reason, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["callee"] = tars::JsonOutput::writeJson(callee);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getNumberRouting", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getNumberRouting", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(displayName, 4, true);
            _is.read(coreNetId, 5, true);
            _is.read(reason, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                    _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getNumberRouting", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getNumberRouting(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const std::string &callee,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(callee, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["callee"] = tars::JsonOutput::writeJson(callee);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getNumberRouting", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getNumberRouting", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr > promise_async_getNumberRouting(const std::string &tableName,const std::string &domainIdAppId,const std::string &callee,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromisegetNumberRoutingPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(callee, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNumberRouting", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getNumberRouting(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const std::string &callee,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(callee, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getNumberRouting", _os, context, _mStatus, callback, true);
        }

        tars::Bool getSipCallRecordEx(const std::string & domainId,const std::string & appId,const std::string & rcpCallId,VoipApp::SipCallRecord &record,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(rcpCallId, 3);
            _os.write(record, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["rcpCallId"] = tars::JsonOutput::writeJson(rcpCallId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getSipCallRecordEx", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getSipCallRecordEx", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(record, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["record"] = tars::JsonOutput::writeJson(record);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getSipCallRecordEx", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getSipCallRecordEx(SipDbPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const std::string &rcpCallId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(rcpCallId, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["rcpCallId"] = tars::JsonOutput::writeJson(rcpCallId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getSipCallRecordEx", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getSipCallRecordEx", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr > promise_async_getSipCallRecordEx(const std::string &domainId,const std::string &appId,const std::string &rcpCallId,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromisegetSipCallRecordExPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(rcpCallId, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getSipCallRecordEx", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getSipCallRecordEx(SipDbCoroPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const std::string &rcpCallId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(rcpCallId, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getSipCallRecordEx", _os, context, _mStatus, callback, true);
        }

        tars::Bool insertCallRecords(const std::string & tableName,const std::string & domainId,const std::string & appId,const vector<VoipApp::CallRecord> & records,const map<std::string, std::string> & params,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainId, 2);
            _os.write(appId, 3);
            _os.write(records, 4);
            _os.write(params, 5);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["records"] = tars::JsonOutput::writeJson(records);
                    _p_->value["params"] = tars::JsonOutput::writeJson(params);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertCallRecords", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertCallRecords", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "insertCallRecords", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_insertCallRecords(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &domainId,const std::string &appId,const vector<VoipApp::CallRecord> &records,const map<std::string, std::string> &params,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainId, 2);
            _os.write(appId, 3);
            _os.write(records, 4);
            _os.write(params, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["records"] = tars::JsonOutput::writeJson(records);
                    _p_->value["params"] = tars::JsonOutput::writeJson(params);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertCallRecords", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"insertCallRecords", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr > promise_async_insertCallRecords(const std::string &tableName,const std::string &domainId,const std::string &appId,const vector<VoipApp::CallRecord> &records,const map<std::string, std::string> &params,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseinsertCallRecordsPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainId, 2);
            _os.write(appId, 3);
            _os.write(records, 4);
            _os.write(params, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertCallRecords", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertCallRecords(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &domainId,const std::string &appId,const vector<VoipApp::CallRecord> &records,const map<std::string, std::string> &params,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainId, 2);
            _os.write(appId, 3);
            _os.write(records, 4);
            _os.write(params, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertCallRecords", _os, context, _mStatus, callback, true);
        }

        tars::Bool insertNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const vector<VoipApp::NumRouting> & numRouting,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            _os.write(reason, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertNumberRouting", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertNumberRouting", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(reason, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "insertNumberRouting", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_insertNumberRouting(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertNumberRouting", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"insertNumberRouting", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr > promise_async_insertNumberRouting(const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseinsertNumberRoutingPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertNumberRouting", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertNumberRouting(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertNumberRouting", _os, context, _mStatus, callback, true);
        }

        tars::Bool insertRecordsBatch(const std::string & domainId,const std::string & appId,const vector<VoipApp::SipCallRecord> & records,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(records, 3);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["records"] = tars::JsonOutput::writeJson(records);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertRecordsBatch", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"insertRecordsBatch", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "insertRecordsBatch", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_insertRecordsBatch(SipDbPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const vector<VoipApp::SipCallRecord> &records,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(records, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["records"] = tars::JsonOutput::writeJson(records);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "insertRecordsBatch", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"insertRecordsBatch", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr > promise_async_insertRecordsBatch(const std::string &domainId,const std::string &appId,const vector<VoipApp::SipCallRecord> &records,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseinsertRecordsBatchPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(records, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertRecordsBatch", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_insertRecordsBatch(SipDbCoroPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const vector<VoipApp::SipCallRecord> &records,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(records, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"insertRecordsBatch", _os, context, _mStatus, callback, true);
        }

        tars::Bool removeNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const vector<VoipApp::NumRouting> & numRouting,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            _os.write(reason, 4);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "removeNumberRouting", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"removeNumberRouting", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(reason, 4, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "removeNumberRouting", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_removeNumberRouting(SipDbPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                    _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                    _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "removeNumberRouting", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"removeNumberRouting", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr > promise_async_removeNumberRouting(const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseremoveNumberRoutingPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"removeNumberRouting", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_removeNumberRouting(SipDbCoroPrxCallbackPtr callback,const std::string &tableName,const std::string &domainIdAppId,const vector<VoipApp::NumRouting> &numRouting,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(tableName, 1);
            _os.write(domainIdAppId, 2);
            _os.write(numRouting, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"removeNumberRouting", _os, context, _mStatus, callback, true);
        }

        tars::Bool updateDomainLineConfig(const std::string & domainId,const std::string & appId,const std::string & coreNetId,const std::string & origSbcIp,const std::string & origSbcPort,const std::string & dstSbcIp,const std::string & dstSbcPort,std::string &reason,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(coreNetId, 3);
            _os.write(origSbcIp, 4);
            _os.write(origSbcPort, 5);
            _os.write(dstSbcIp, 6);
            _os.write(dstSbcPort, 7);
            _os.write(reason, 8);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                    _p_->value["origSbcIp"] = tars::JsonOutput::writeJson(origSbcIp);
                    _p_->value["origSbcPort"] = tars::JsonOutput::writeJson(origSbcPort);
                    _p_->value["dstSbcIp"] = tars::JsonOutput::writeJson(dstSbcIp);
                    _p_->value["dstSbcPort"] = tars::JsonOutput::writeJson(dstSbcPort);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "updateDomainLineConfig", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"updateDomainLineConfig", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(reason, 8, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "updateDomainLineConfig", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_updateDomainLineConfig(SipDbPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const std::string &coreNetId,const std::string &origSbcIp,const std::string &origSbcPort,const std::string &dstSbcIp,const std::string &dstSbcPort,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(coreNetId, 3);
            _os.write(origSbcIp, 4);
            _os.write(origSbcPort, 5);
            _os.write(dstSbcIp, 6);
            _os.write(dstSbcPort, 7);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                    _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                    _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                    _p_->value["origSbcIp"] = tars::JsonOutput::writeJson(origSbcIp);
                    _p_->value["origSbcPort"] = tars::JsonOutput::writeJson(origSbcPort);
                    _p_->value["dstSbcIp"] = tars::JsonOutput::writeJson(dstSbcIp);
                    _p_->value["dstSbcPort"] = tars::JsonOutput::writeJson(dstSbcPort);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "updateDomainLineConfig", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"updateDomainLineConfig", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr > promise_async_updateDomainLineConfig(const std::string &domainId,const std::string &appId,const std::string &coreNetId,const std::string &origSbcIp,const std::string &origSbcPort,const std::string &dstSbcIp,const std::string &dstSbcPort,const map<string, string>& context)
        {
            tars::Promise< SipDbPrxCallbackPromise::PromiseupdateDomainLineConfigPtr > promise;
            SipDbPrxCallbackPromisePtr callback (new SipDbPrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(coreNetId, 3);
            _os.write(origSbcIp, 4);
            _os.write(origSbcPort, 5);
            _os.write(dstSbcIp, 6);
            _os.write(dstSbcPort, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updateDomainLineConfig", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_updateDomainLineConfig(SipDbCoroPrxCallbackPtr callback,const std::string &domainId,const std::string &appId,const std::string &coreNetId,const std::string &origSbcIp,const std::string &origSbcPort,const std::string &dstSbcIp,const std::string &dstSbcPort,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(domainId, 1);
            _os.write(appId, 2);
            _os.write(coreNetId, 3);
            _os.write(origSbcIp, 4);
            _os.write(origSbcPort, 5);
            _os.write(dstSbcIp, 6);
            _os.write(dstSbcPort, 7);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"updateDomainLineConfig", _os, context, _mStatus, callback, true);
        }

        SipDbProxy* tars_hash(size_t key)
        {
            return (SipDbProxy*)ServantProxy::tars_hash(key);
        }

        SipDbProxy* tars_consistent_hash(size_t key)
        {
            return (SipDbProxy*)ServantProxy::tars_consistent_hash(key);
        }

        SipDbProxy* tars_open_trace(bool traceParam = false)
        {
            return (SipDbProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        SipDbProxy* tars_set_timeout(int msecond)
        {
            return (SipDbProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "SipDbProxy"; }
    };
    typedef tars::TC_AutoPtr<SipDbProxy> SipDbPrx;

    /* servant for server */
    class SipDb : public tars::Servant
    {
    public:
        virtual ~SipDb(){}
        virtual tars::Bool GetAllAllowedIps(const std::string & tableName,vector<VoipApp::AllowedIp> &vectIps,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetAllAllowedIps(std::string && tableName,vector<VoipApp::AllowedIp> &vectIps,tars::TarsCurrentPtr _current_) 
        { return GetAllAllowedIps(tableName, vectIps, _current_); }
        static void async_response_GetAllAllowedIps(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::AllowedIp> &vectIps)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("vectIps", vectIps);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectIps, 2);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetAllAllowedIps", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetAllAllowedIps(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::AllowedIp> &vectIps, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectIps, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetAllAllowedIps", _os, _context);
            }
        }

        virtual tars::Bool GetAllCallSipPolicys(const std::string & tableName,vector<VoipApp::CallSipPolicy> &policys,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetAllCallSipPolicys(std::string && tableName,vector<VoipApp::CallSipPolicy> &policys,tars::TarsCurrentPtr _current_) 
        { return GetAllCallSipPolicys(tableName, policys, _current_); }
        static void async_response_GetAllCallSipPolicys(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::CallSipPolicy> &policys)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("policys", policys);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["policys"] = tars::JsonOutput::writeJson(policys);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(policys, 2);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["policys"] = tars::JsonOutput::writeJson(policys);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetAllCallSipPolicys", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetAllCallSipPolicys(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::CallSipPolicy> &policys, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(policys, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetAllCallSipPolicys", _os, _context);
            }
        }

        virtual tars::Bool GetAllNationCodeIps(const std::string & tableName,vector<VoipApp::NationCodeIp> &vectIps,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetAllNationCodeIps(std::string && tableName,vector<VoipApp::NationCodeIp> &vectIps,tars::TarsCurrentPtr _current_) 
        { return GetAllNationCodeIps(tableName, vectIps, _current_); }
        static void async_response_GetAllNationCodeIps(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::NationCodeIp> &vectIps)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("vectIps", vectIps);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectIps, 2);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetAllNationCodeIps", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetAllNationCodeIps(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::NationCodeIp> &vectIps, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectIps, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetAllNationCodeIps", _os, _context);
            }
        }

        virtual tars::Bool GetDomainAccessInfo(const std::string & tableName,vector<VoipApp::DomainAccessedConfig> &vectDomainAccessed,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetDomainAccessInfo(std::string && tableName,vector<VoipApp::DomainAccessedConfig> &vectDomainAccessed,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return GetDomainAccessInfo(tableName, vectDomainAccessed, reason, _current_); }
        static void async_response_GetDomainAccessInfo(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainAccessedConfig> &vectDomainAccessed, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("vectDomainAccessed", vectDomainAccessed);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectDomainAccessed, 2);

                _os.write(reason, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetDomainAccessInfo", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetDomainAccessInfo(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainAccessedConfig> &vectDomainAccessed, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectDomainAccessed, 2);

                _os.write(reason, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetDomainAccessInfo", _os, _context);
            }
        }

        virtual tars::Bool GetDomainAccessInfo2(const std::string & tableName,vector<VoipApp::DomainAccessedConfig2> &vectDomainAccessed,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetDomainAccessInfo2(std::string && tableName,vector<VoipApp::DomainAccessedConfig2> &vectDomainAccessed,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return GetDomainAccessInfo2(tableName, vectDomainAccessed, reason, _current_); }
        static void async_response_GetDomainAccessInfo2(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainAccessedConfig2> &vectDomainAccessed, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("vectDomainAccessed", vectDomainAccessed);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectDomainAccessed, 2);

                _os.write(reason, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetDomainAccessInfo2", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetDomainAccessInfo2(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainAccessedConfig2> &vectDomainAccessed, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectDomainAccessed, 2);

                _os.write(reason, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetDomainAccessInfo2", _os, _context);
            }
        }

        virtual tars::Bool GetRtpGatewayconfigInfo(const std::string & tableName,vector<VoipApp::RtpGatewayAccessedConfig> &rtpGatewayConfigLst,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetRtpGatewayconfigInfo(std::string && tableName,vector<VoipApp::RtpGatewayAccessedConfig> &rtpGatewayConfigLst,tars::TarsCurrentPtr _current_) 
        { return GetRtpGatewayconfigInfo(tableName, rtpGatewayConfigLst, _current_); }
        static void async_response_GetRtpGatewayconfigInfo(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::RtpGatewayAccessedConfig> &rtpGatewayConfigLst)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("rtpGatewayConfigLst", rtpGatewayConfigLst);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(rtpGatewayConfigLst, 2);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetRtpGatewayconfigInfo(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::RtpGatewayAccessedConfig> &rtpGatewayConfigLst, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(rtpGatewayConfigLst, 2);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetRtpGatewayconfigInfo", _os, _context);
            }
        }

        virtual tars::Bool GetSipProxyAccessCoreNetInfo(const std::string & tableName,vector<VoipApp::SipProxyAccessedCoreNetConfig> &vectSipProxyAccessedConfig,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool GetSipProxyAccessCoreNetInfo(std::string && tableName,vector<VoipApp::SipProxyAccessedCoreNetConfig> &vectSipProxyAccessedConfig,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return GetSipProxyAccessCoreNetInfo(tableName, vectSipProxyAccessedConfig, reason, _current_); }
        static void async_response_GetSipProxyAccessCoreNetInfo(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::SipProxyAccessedCoreNetConfig> &vectSipProxyAccessedConfig, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("vectSipProxyAccessedConfig", vectSipProxyAccessedConfig);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectSipProxyAccessedConfig, 2);

                _os.write(reason, 3);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_GetSipProxyAccessCoreNetInfo(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::SipProxyAccessedCoreNetConfig> &vectSipProxyAccessedConfig, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(vectSipProxyAccessedConfig, 2);

                _os.write(reason, 3);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"GetSipProxyAccessCoreNetInfo", _os, _context);
            }
        }

        virtual tars::Bool SetRtpGatewayAccessedId(const std::string & tableName,const std::string & rtpGatewayName,const std::string & rtpGatewayId,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool SetRtpGatewayAccessedId(std::string && tableName,std::string && rtpGatewayName,std::string && rtpGatewayId,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return SetRtpGatewayAccessedId(tableName, rtpGatewayName, rtpGatewayId, reason, _current_); }
        static void async_response_SetRtpGatewayAccessedId(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_SetRtpGatewayAccessedId(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"SetRtpGatewayAccessedId", _os, _context);
            }
        }

        virtual tars::Bool SetSipProxyAccessedId(const std::string & tableName,const std::string & sipProxyName,const std::string & sipProxyid,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool SetSipProxyAccessedId(std::string && tableName,std::string && sipProxyName,std::string && sipProxyid,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return SetSipProxyAccessedId(tableName, sipProxyName, sipProxyid, reason, _current_); }
        static void async_response_SetSipProxyAccessedId(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "SetSipProxyAccessedId", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_SetSipProxyAccessedId(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"SetSipProxyAccessedId", _os, _context);
            }
        }

        virtual tars::Bool UpdateCallSipPolicys(const std::string & tableName,const vector<VoipApp::CallSipPolicyOperation> & OpSequence,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool UpdateCallSipPolicys(std::string && tableName,vector<VoipApp::CallSipPolicyOperation> && OpSequence,tars::TarsCurrentPtr _current_) 
        { return UpdateCallSipPolicys(tableName, OpSequence, _current_); }
        static void async_response_UpdateCallSipPolicys(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "UpdateCallSipPolicys", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_UpdateCallSipPolicys(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"UpdateCallSipPolicys", _os, _context);
            }
        }

        virtual tars::Bool UpdateDomainAccessConfig(const std::string & tableName,const vector<VoipApp::DomainAccessConfigOperation> & OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool UpdateDomainAccessConfig(std::string && tableName,vector<VoipApp::DomainAccessConfigOperation> && OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) 
        { return UpdateDomainAccessConfig(tableName, OpSequence, insertedTime, _current_); }
        static void async_response_UpdateDomainAccessConfig(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_UpdateDomainAccessConfig(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"UpdateDomainAccessConfig", _os, _context);
            }
        }

        virtual tars::Bool UpdateDomainAccessConfig2(const std::string & tableName,const vector<VoipApp::DomainAccessConfigOperation2> & OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool UpdateDomainAccessConfig2(std::string && tableName,vector<VoipApp::DomainAccessConfigOperation2> && OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) 
        { return UpdateDomainAccessConfig2(tableName, OpSequence, insertedTime, _current_); }
        static void async_response_UpdateDomainAccessConfig2(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_UpdateDomainAccessConfig2(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"UpdateDomainAccessConfig2", _os, _context);
            }
        }

        virtual tars::Bool UpdateSipProxyAccessConfig(const std::string & tableName,const vector<VoipApp::SipProxyConfigOperation> & OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool UpdateSipProxyAccessConfig(std::string && tableName,vector<VoipApp::SipProxyConfigOperation> && OpSequence,tars::Int64 insertedTime,tars::TarsCurrentPtr _current_) 
        { return UpdateSipProxyAccessConfig(tableName, OpSequence, insertedTime, _current_); }
        static void async_response_UpdateSipProxyAccessConfig(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_UpdateSipProxyAccessConfig(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"UpdateSipProxyAccessConfig", _os, _context);
            }
        }

        virtual tars::Bool getDomainLineConfig(const std::string & domainId,const std::string & appId,vector<VoipApp::DomainLineConfig> &config,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getDomainLineConfig(std::string && domainId,std::string && appId,vector<VoipApp::DomainLineConfig> &config,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return getDomainLineConfig(domainId, appId, config, reason, _current_); }
        static void async_response_getDomainLineConfig(tars::TarsCurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainLineConfig> &config, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("config", config);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["config"] = tars::JsonOutput::writeJson(config);
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(config, 3);

                _os.write(reason, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["config"] = tars::JsonOutput::writeJson(config);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getDomainLineConfig", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getDomainLineConfig(tars::CurrentPtr _current_, tars::Bool _ret, const vector<VoipApp::DomainLineConfig> &config, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(config, 3);

                _os.write(reason, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getDomainLineConfig", _os, _context);
            }
        }

        virtual tars::Bool getNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const std::string & callee,std::string &displayName,std::string &coreNetId,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getNumberRouting(std::string && tableName,std::string && domainIdAppId,std::string && callee,std::string &displayName,std::string &coreNetId,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return getNumberRouting(tableName, domainIdAppId, callee, displayName, coreNetId, reason, _current_); }
        static void async_response_getNumberRouting(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &displayName, const std::string &coreNetId, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("displayName", displayName);
                _tarsAttr_.put("coreNetId", coreNetId);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                _p->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(displayName, 4);

                _os.write(coreNetId, 5);

                _os.write(reason, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                    _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getNumberRouting", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getNumberRouting(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &displayName, const std::string &coreNetId, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(displayName, 4);

                _os.write(coreNetId, 5);

                _os.write(reason, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getNumberRouting", _os, _context);
            }
        }

        virtual tars::Bool getSipCallRecordEx(const std::string & domainId,const std::string & appId,const std::string & rcpCallId,VoipApp::SipCallRecord &record,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getSipCallRecordEx(std::string && domainId,std::string && appId,std::string && rcpCallId,VoipApp::SipCallRecord &record,tars::TarsCurrentPtr _current_) 
        { return getSipCallRecordEx(domainId, appId, rcpCallId, record, _current_); }
        static void async_response_getSipCallRecordEx(tars::TarsCurrentPtr _current_, tars::Bool _ret, const VoipApp::SipCallRecord &record)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("record", record);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["record"] = tars::JsonOutput::writeJson(record);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(record, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["record"] = tars::JsonOutput::writeJson(record);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getSipCallRecordEx", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getSipCallRecordEx(tars::CurrentPtr _current_, tars::Bool _ret, const VoipApp::SipCallRecord &record, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(record, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getSipCallRecordEx", _os, _context);
            }
        }

        virtual tars::Bool insertCallRecords(const std::string & tableName,const std::string & domainId,const std::string & appId,const vector<VoipApp::CallRecord> & records,const map<std::string, std::string> & params,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool insertCallRecords(std::string && tableName,std::string && domainId,std::string && appId,vector<VoipApp::CallRecord> && records,map<std::string, std::string> && params,tars::TarsCurrentPtr _current_) 
        { return insertCallRecords(tableName, domainId, appId, records, params, _current_); }
        static void async_response_insertCallRecords(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "insertCallRecords", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_insertCallRecords(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertCallRecords", _os, _context);
            }
        }

        virtual tars::Bool insertNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const vector<VoipApp::NumRouting> & numRouting,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool insertNumberRouting(std::string && tableName,std::string && domainIdAppId,vector<VoipApp::NumRouting> && numRouting,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return insertNumberRouting(tableName, domainIdAppId, numRouting, reason, _current_); }
        static void async_response_insertNumberRouting(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "insertNumberRouting", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_insertNumberRouting(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertNumberRouting", _os, _context);
            }
        }

        virtual tars::Bool insertRecordsBatch(const std::string & domainId,const std::string & appId,const vector<VoipApp::SipCallRecord> & records,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool insertRecordsBatch(std::string && domainId,std::string && appId,vector<VoipApp::SipCallRecord> && records,tars::TarsCurrentPtr _current_) 
        { return insertRecordsBatch(domainId, appId, records, _current_); }
        static void async_response_insertRecordsBatch(tars::TarsCurrentPtr _current_, tars::Bool _ret)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "insertRecordsBatch", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_insertRecordsBatch(tars::CurrentPtr _current_, tars::Bool _ret, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"insertRecordsBatch", _os, _context);
            }
        }

        virtual tars::Bool removeNumberRouting(const std::string & tableName,const std::string & domainIdAppId,const vector<VoipApp::NumRouting> & numRouting,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool removeNumberRouting(std::string && tableName,std::string && domainIdAppId,vector<VoipApp::NumRouting> && numRouting,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return removeNumberRouting(tableName, domainIdAppId, numRouting, reason, _current_); }
        static void async_response_removeNumberRouting(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "removeNumberRouting", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_removeNumberRouting(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 4);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"removeNumberRouting", _os, _context);
            }
        }

        virtual tars::Bool updateDomainLineConfig(const std::string & domainId,const std::string & appId,const std::string & coreNetId,const std::string & origSbcIp,const std::string & origSbcPort,const std::string & dstSbcIp,const std::string & dstSbcPort,std::string &reason,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool updateDomainLineConfig(std::string && domainId,std::string && appId,std::string && coreNetId,std::string && origSbcIp,std::string && origSbcPort,std::string && dstSbcIp,std::string && dstSbcPort,std::string &reason,tars::TarsCurrentPtr _current_) 
        { return updateDomainLineConfig(domainId, appId, coreNetId, origSbcIp, origSbcPort, dstSbcIp, dstSbcPort, reason, _current_); }
        static void async_response_updateDomainLineConfig(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &reason)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("reason", reason);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 8);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "updateDomainLineConfig", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_updateDomainLineConfig(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &reason, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(reason, 8);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"updateDomainLineConfig", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __VoipApp__SipDb_all[]=
            {
                "GetAllAllowedIps",
                "GetAllCallSipPolicys",
                "GetAllNationCodeIps",
                "GetDomainAccessInfo",
                "GetDomainAccessInfo2",
                "GetRtpGatewayconfigInfo",
                "GetSipProxyAccessCoreNetInfo",
                "SetRtpGatewayAccessedId",
                "SetSipProxyAccessedId",
                "UpdateCallSipPolicys",
                "UpdateDomainAccessConfig",
                "UpdateDomainAccessConfig2",
                "UpdateSipProxyAccessConfig",
                "getDomainLineConfig",
                "getNumberRouting",
                "getSipCallRecordEx",
                "insertCallRecords",
                "insertNumberRouting",
                "insertRecordsBatch",
                "removeNumberRouting",
                "updateDomainLineConfig"
            };

            pair<string*, string*> r = equal_range(__VoipApp__SipDb_all, __VoipApp__SipDb_all+21, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __VoipApp__SipDb_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::AllowedIp> vectIps;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("vectIps", vectIps, vectIps);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(vectIps, _jsonPtr->value["vectIps"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(vectIps, 2, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetAllAllowedIps", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetAllAllowedIps(std::move(tableName),vectIps, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("vectIps", vectIps);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(vectIps, 2);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetAllAllowedIps", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::CallSipPolicy> policys;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("policys", policys, policys);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(policys, _jsonPtr->value["policys"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(policys, 2, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetAllCallSipPolicys", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetAllCallSipPolicys(std::move(tableName),policys, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("policys", policys);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["policys"] = tars::JsonOutput::writeJson(policys);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(policys, 2);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["policys"] = tars::JsonOutput::writeJson(policys);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetAllCallSipPolicys", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::NationCodeIp> vectIps;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("vectIps", vectIps, vectIps);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(vectIps, _jsonPtr->value["vectIps"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(vectIps, 2, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetAllNationCodeIps", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetAllNationCodeIps(std::move(tableName),vectIps, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("vectIps", vectIps);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(vectIps, 2);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["vectIps"] = tars::JsonOutput::writeJson(vectIps);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetAllNationCodeIps", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::DomainAccessedConfig> vectDomainAccessed;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("vectDomainAccessed", vectDomainAccessed, vectDomainAccessed);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(vectDomainAccessed, _jsonPtr->value["vectDomainAccessed"], false);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(vectDomainAccessed, 2, false);
                        _is.read(reason, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetDomainAccessInfo", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetDomainAccessInfo(std::move(tableName),vectDomainAccessed,reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("vectDomainAccessed", vectDomainAccessed);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(vectDomainAccessed, 2);
                            _os.write(reason, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetDomainAccessInfo", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::DomainAccessedConfig2> vectDomainAccessed;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("vectDomainAccessed", vectDomainAccessed, vectDomainAccessed);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(vectDomainAccessed, _jsonPtr->value["vectDomainAccessed"], false);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(vectDomainAccessed, 2, false);
                        _is.read(reason, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetDomainAccessInfo2", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetDomainAccessInfo2(std::move(tableName),vectDomainAccessed,reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("vectDomainAccessed", vectDomainAccessed);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(vectDomainAccessed, 2);
                            _os.write(reason, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["vectDomainAccessed"] = tars::JsonOutput::writeJson(vectDomainAccessed);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetDomainAccessInfo2", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::RtpGatewayAccessedConfig> rtpGatewayConfigLst;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("rtpGatewayConfigLst", rtpGatewayConfigLst, rtpGatewayConfigLst);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(rtpGatewayConfigLst, _jsonPtr->value["rtpGatewayConfigLst"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(rtpGatewayConfigLst, 2, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetRtpGatewayconfigInfo(std::move(tableName),rtpGatewayConfigLst, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("rtpGatewayConfigLst", rtpGatewayConfigLst);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(rtpGatewayConfigLst, 2);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["rtpGatewayConfigLst"] = tars::JsonOutput::writeJson(rtpGatewayConfigLst);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetRtpGatewayconfigInfo", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::SipProxyAccessedCoreNetConfig> vectSipProxyAccessedConfig;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.getByDefault("vectSipProxyAccessedConfig", vectSipProxyAccessedConfig, vectSipProxyAccessedConfig);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(vectSipProxyAccessedConfig, _jsonPtr->value["vectSipProxyAccessedConfig"], false);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(vectSipProxyAccessedConfig, 2, false);
                        _is.read(reason, 3, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = GetSipProxyAccessCoreNetInfo(std::move(tableName),vectSipProxyAccessedConfig,reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("vectSipProxyAccessedConfig", vectSipProxyAccessedConfig);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(vectSipProxyAccessedConfig, 2);
                            _os.write(reason, 3);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["vectSipProxyAccessedConfig"] = tars::JsonOutput::writeJson(vectSipProxyAccessedConfig);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "GetSipProxyAccessCoreNetInfo", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string rtpGatewayName;
                    std::string rtpGatewayId;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("rtpGatewayName", rtpGatewayName);
                        _tarsAttr_.get("rtpGatewayId", rtpGatewayId);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(rtpGatewayName, _jsonPtr->value["rtpGatewayName"], true);
                        tars::JsonInput::readJson(rtpGatewayId, _jsonPtr->value["rtpGatewayId"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(rtpGatewayName, 2, true);
                        _is.read(rtpGatewayId, 3, true);
                        _is.read(reason, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["rtpGatewayName"] = tars::JsonOutput::writeJson(rtpGatewayName);
                            _p_->value["rtpGatewayId"] = tars::JsonOutput::writeJson(rtpGatewayId);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = SetRtpGatewayAccessedId(std::move(tableName),std::move(rtpGatewayName),std::move(rtpGatewayId),reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(reason, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "SetRtpGatewayAccessedId", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string sipProxyName;
                    std::string sipProxyid;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("sipProxyName", sipProxyName);
                        _tarsAttr_.get("sipProxyid", sipProxyid);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(sipProxyName, _jsonPtr->value["sipProxyName"], true);
                        tars::JsonInput::readJson(sipProxyid, _jsonPtr->value["sipProxyid"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(sipProxyName, 2, true);
                        _is.read(sipProxyid, 3, true);
                        _is.read(reason, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["sipProxyName"] = tars::JsonOutput::writeJson(sipProxyName);
                            _p_->value["sipProxyid"] = tars::JsonOutput::writeJson(sipProxyid);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "SetSipProxyAccessedId", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = SetSipProxyAccessedId(std::move(tableName),std::move(sipProxyName),std::move(sipProxyid),reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(reason, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "SetSipProxyAccessedId", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::CallSipPolicyOperation> OpSequence;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("OpSequence", OpSequence);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(OpSequence, _jsonPtr->value["OpSequence"], true);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(OpSequence, 2, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "UpdateCallSipPolicys", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = UpdateCallSipPolicys(std::move(tableName),std::move(OpSequence), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "UpdateCallSipPolicys", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::DomainAccessConfigOperation> OpSequence;
                    tars::Int64 insertedTime;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("OpSequence", OpSequence);
                        _tarsAttr_.get("insertedTime", insertedTime);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(OpSequence, _jsonPtr->value["OpSequence"], true);
                        tars::JsonInput::readJson(insertedTime, _jsonPtr->value["insertedTime"], true);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(OpSequence, 2, true);
                        _is.read(insertedTime, 3, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                            _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = UpdateDomainAccessConfig(std::move(tableName),std::move(OpSequence),insertedTime, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "UpdateDomainAccessConfig", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::DomainAccessConfigOperation2> OpSequence;
                    tars::Int64 insertedTime;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("OpSequence", OpSequence);
                        _tarsAttr_.get("insertedTime", insertedTime);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(OpSequence, _jsonPtr->value["OpSequence"], true);
                        tars::JsonInput::readJson(insertedTime, _jsonPtr->value["insertedTime"], true);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(OpSequence, 2, true);
                        _is.read(insertedTime, 3, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                            _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = UpdateDomainAccessConfig2(std::move(tableName),std::move(OpSequence),insertedTime, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "UpdateDomainAccessConfig2", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    vector<VoipApp::SipProxyConfigOperation> OpSequence;
                    tars::Int64 insertedTime;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("OpSequence", OpSequence);
                        _tarsAttr_.get("insertedTime", insertedTime);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(OpSequence, _jsonPtr->value["OpSequence"], true);
                        tars::JsonInput::readJson(insertedTime, _jsonPtr->value["insertedTime"], true);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(OpSequence, 2, true);
                        _is.read(insertedTime, 3, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["OpSequence"] = tars::JsonOutput::writeJson(OpSequence);
                            _p_->value["insertedTime"] = tars::JsonOutput::writeJson(insertedTime);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = UpdateSipProxyAccessConfig(std::move(tableName),std::move(OpSequence),insertedTime, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "UpdateSipProxyAccessConfig", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string domainId;
                    std::string appId;
                    vector<VoipApp::DomainLineConfig> config;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("domainId", domainId);
                        _tarsAttr_.get("appId", appId);
                        _tarsAttr_.getByDefault("config", config, config);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(domainId, _jsonPtr->value["domainId"], true);
                        tars::JsonInput::readJson(appId, _jsonPtr->value["appId"], true);
                        tars::JsonInput::readJson(config, _jsonPtr->value["config"], false);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(domainId, 1, true);
                        _is.read(appId, 2, true);
                        _is.read(config, 3, false);
                        _is.read(reason, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                            _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getDomainLineConfig", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getDomainLineConfig(std::move(domainId),std::move(appId),config,reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("config", config);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["config"] = tars::JsonOutput::writeJson(config);
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(config, 3);
                            _os.write(reason, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["config"] = tars::JsonOutput::writeJson(config);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getDomainLineConfig", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string domainIdAppId;
                    std::string callee;
                    std::string displayName;
                    std::string coreNetId;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("domainIdAppId", domainIdAppId);
                        _tarsAttr_.get("callee", callee);
                        _tarsAttr_.getByDefault("displayName", displayName, displayName);
                        _tarsAttr_.getByDefault("coreNetId", coreNetId, coreNetId);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(domainIdAppId, _jsonPtr->value["domainIdAppId"], true);
                        tars::JsonInput::readJson(callee, _jsonPtr->value["callee"], true);
                        tars::JsonInput::readJson(displayName, _jsonPtr->value["displayName"], false);
                        tars::JsonInput::readJson(coreNetId, _jsonPtr->value["coreNetId"], false);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(domainIdAppId, 2, true);
                        _is.read(callee, 3, true);
                        _is.read(displayName, 4, false);
                        _is.read(coreNetId, 5, false);
                        _is.read(reason, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                            _p_->value["callee"] = tars::JsonOutput::writeJson(callee);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getNumberRouting", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getNumberRouting(std::move(tableName),std::move(domainIdAppId),std::move(callee),displayName,coreNetId,reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("displayName", displayName);
                            _tarsAttr_.put("coreNetId", coreNetId);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                            _p->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(displayName, 4);
                            _os.write(coreNetId, 5);
                            _os.write(reason, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["displayName"] = tars::JsonOutput::writeJson(displayName);
                                _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getNumberRouting", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string domainId;
                    std::string appId;
                    std::string rcpCallId;
                    VoipApp::SipCallRecord record;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("domainId", domainId);
                        _tarsAttr_.get("appId", appId);
                        _tarsAttr_.get("rcpCallId", rcpCallId);
                        _tarsAttr_.getByDefault("record", record, record);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(domainId, _jsonPtr->value["domainId"], true);
                        tars::JsonInput::readJson(appId, _jsonPtr->value["appId"], true);
                        tars::JsonInput::readJson(rcpCallId, _jsonPtr->value["rcpCallId"], true);
                        tars::JsonInput::readJson(record, _jsonPtr->value["record"], false);
                    }
                    else
                    {
                        _is.read(domainId, 1, true);
                        _is.read(appId, 2, true);
                        _is.read(rcpCallId, 3, true);
                        _is.read(record, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                            _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                            _p_->value["rcpCallId"] = tars::JsonOutput::writeJson(rcpCallId);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getSipCallRecordEx", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getSipCallRecordEx(std::move(domainId),std::move(appId),std::move(rcpCallId),record, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("record", record);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["record"] = tars::JsonOutput::writeJson(record);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(record, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["record"] = tars::JsonOutput::writeJson(record);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getSipCallRecordEx", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string domainId;
                    std::string appId;
                    vector<VoipApp::CallRecord> records;
                    map<std::string, std::string> params;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("domainId", domainId);
                        _tarsAttr_.get("appId", appId);
                        _tarsAttr_.get("records", records);
                        _tarsAttr_.get("params", params);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(domainId, _jsonPtr->value["domainId"], true);
                        tars::JsonInput::readJson(appId, _jsonPtr->value["appId"], true);
                        tars::JsonInput::readJson(records, _jsonPtr->value["records"], true);
                        tars::JsonInput::readJson(params, _jsonPtr->value["params"], true);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(domainId, 2, true);
                        _is.read(appId, 3, true);
                        _is.read(records, 4, true);
                        _is.read(params, 5, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                            _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                            _p_->value["records"] = tars::JsonOutput::writeJson(records);
                            _p_->value["params"] = tars::JsonOutput::writeJson(params);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "insertCallRecords", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = insertCallRecords(std::move(tableName),std::move(domainId),std::move(appId),std::move(records),std::move(params), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "insertCallRecords", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string domainIdAppId;
                    vector<VoipApp::NumRouting> numRouting;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("domainIdAppId", domainIdAppId);
                        _tarsAttr_.get("numRouting", numRouting);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(domainIdAppId, _jsonPtr->value["domainIdAppId"], true);
                        tars::JsonInput::readJson(numRouting, _jsonPtr->value["numRouting"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(domainIdAppId, 2, true);
                        _is.read(numRouting, 3, true);
                        _is.read(reason, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                            _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "insertNumberRouting", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = insertNumberRouting(std::move(tableName),std::move(domainIdAppId),std::move(numRouting),reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(reason, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "insertNumberRouting", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string domainId;
                    std::string appId;
                    vector<VoipApp::SipCallRecord> records;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("domainId", domainId);
                        _tarsAttr_.get("appId", appId);
                        _tarsAttr_.get("records", records);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(domainId, _jsonPtr->value["domainId"], true);
                        tars::JsonInput::readJson(appId, _jsonPtr->value["appId"], true);
                        tars::JsonInput::readJson(records, _jsonPtr->value["records"], true);
                    }
                    else
                    {
                        _is.read(domainId, 1, true);
                        _is.read(appId, 2, true);
                        _is.read(records, 3, true);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                            _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                            _p_->value["records"] = tars::JsonOutput::writeJson(records);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "insertRecordsBatch", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = insertRecordsBatch(std::move(domainId),std::move(appId),std::move(records), _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "insertRecordsBatch", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 19:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string tableName;
                    std::string domainIdAppId;
                    vector<VoipApp::NumRouting> numRouting;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("tableName", tableName);
                        _tarsAttr_.get("domainIdAppId", domainIdAppId);
                        _tarsAttr_.get("numRouting", numRouting);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(tableName, _jsonPtr->value["tableName"], true);
                        tars::JsonInput::readJson(domainIdAppId, _jsonPtr->value["domainIdAppId"], true);
                        tars::JsonInput::readJson(numRouting, _jsonPtr->value["numRouting"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(tableName, 1, true);
                        _is.read(domainIdAppId, 2, true);
                        _is.read(numRouting, 3, true);
                        _is.read(reason, 4, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["tableName"] = tars::JsonOutput::writeJson(tableName);
                            _p_->value["domainIdAppId"] = tars::JsonOutput::writeJson(domainIdAppId);
                            _p_->value["numRouting"] = tars::JsonOutput::writeJson(numRouting);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "removeNumberRouting", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = removeNumberRouting(std::move(tableName),std::move(domainIdAppId),std::move(numRouting),reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(reason, 4);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "removeNumberRouting", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 20:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string domainId;
                    std::string appId;
                    std::string coreNetId;
                    std::string origSbcIp;
                    std::string origSbcPort;
                    std::string dstSbcIp;
                    std::string dstSbcPort;
                    std::string reason;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("domainId", domainId);
                        _tarsAttr_.get("appId", appId);
                        _tarsAttr_.get("coreNetId", coreNetId);
                        _tarsAttr_.get("origSbcIp", origSbcIp);
                        _tarsAttr_.get("origSbcPort", origSbcPort);
                        _tarsAttr_.get("dstSbcIp", dstSbcIp);
                        _tarsAttr_.get("dstSbcPort", dstSbcPort);
                        _tarsAttr_.getByDefault("reason", reason, reason);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(domainId, _jsonPtr->value["domainId"], true);
                        tars::JsonInput::readJson(appId, _jsonPtr->value["appId"], true);
                        tars::JsonInput::readJson(coreNetId, _jsonPtr->value["coreNetId"], true);
                        tars::JsonInput::readJson(origSbcIp, _jsonPtr->value["origSbcIp"], true);
                        tars::JsonInput::readJson(origSbcPort, _jsonPtr->value["origSbcPort"], true);
                        tars::JsonInput::readJson(dstSbcIp, _jsonPtr->value["dstSbcIp"], true);
                        tars::JsonInput::readJson(dstSbcPort, _jsonPtr->value["dstSbcPort"], true);
                        tars::JsonInput::readJson(reason, _jsonPtr->value["reason"], false);
                    }
                    else
                    {
                        _is.read(domainId, 1, true);
                        _is.read(appId, 2, true);
                        _is.read(coreNetId, 3, true);
                        _is.read(origSbcIp, 4, true);
                        _is.read(origSbcPort, 5, true);
                        _is.read(dstSbcIp, 6, true);
                        _is.read(dstSbcPort, 7, true);
                        _is.read(reason, 8, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["domainId"] = tars::JsonOutput::writeJson(domainId);
                            _p_->value["appId"] = tars::JsonOutput::writeJson(appId);
                            _p_->value["coreNetId"] = tars::JsonOutput::writeJson(coreNetId);
                            _p_->value["origSbcIp"] = tars::JsonOutput::writeJson(origSbcIp);
                            _p_->value["origSbcPort"] = tars::JsonOutput::writeJson(origSbcPort);
                            _p_->value["dstSbcIp"] = tars::JsonOutput::writeJson(dstSbcIp);
                            _p_->value["dstSbcPort"] = tars::JsonOutput::writeJson(dstSbcPort);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "updateDomainLineConfig", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = updateDomainLineConfig(std::move(domainId),std::move(appId),std::move(coreNetId),std::move(origSbcIp),std::move(origSbcPort),std::move(dstSbcIp),std::move(dstSbcPort),reason, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("reason", reason);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["reason"] = tars::JsonOutput::writeJson(reason);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(reason, 8);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["reason"] = tars::JsonOutput::writeJson(reason);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "updateDomainLineConfig", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif

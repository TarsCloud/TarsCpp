// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.21.
// **********************************************************************

#ifndef __SIPCHARGE_H_
#define __SIPCHARGE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace VoipApp
{
    struct OcsChargeInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "VoipApp.OcsChargeInfo";
        }
        static string MD5()
        {
            return "8f9c697a216eacdd694cb2a2e96fe600";
        }
        OcsChargeInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            caller = "";
            callee = "";
            chargeAccount = "";
            midCallUser = "";
            origSrcUser = "";
            origDstUser = "";
            routeId = "";
            atomId = "";
            meetingId = "";
            priceNumber = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(caller, 0);
            _os.write(callee, 1);
            _os.write(chargeAccount, 2);
            _os.write(midCallUser, 3);
            _os.write(origSrcUser, 4);
            _os.write(origDstUser, 5);
            _os.write(routeId, 6);
            _os.write(atomId, 7);
            _os.write(meetingId, 8);
            _os.write(priceNumber, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(caller, 0, true);
            _is.read(callee, 1, true);
            _is.read(chargeAccount, 2, true);
            _is.read(midCallUser, 3, true);
            _is.read(origSrcUser, 4, true);
            _is.read(origDstUser, 5, true);
            _is.read(routeId, 6, true);
            _is.read(atomId, 7, true);
            _is.read(meetingId, 8, true);
            _is.read(priceNumber, 9, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["caller"] = tars::JsonOutput::writeJson(caller);
            p->value["callee"] = tars::JsonOutput::writeJson(callee);
            p->value["chargeAccount"] = tars::JsonOutput::writeJson(chargeAccount);
            p->value["midCallUser"] = tars::JsonOutput::writeJson(midCallUser);
            p->value["origSrcUser"] = tars::JsonOutput::writeJson(origSrcUser);
            p->value["origDstUser"] = tars::JsonOutput::writeJson(origDstUser);
            p->value["routeId"] = tars::JsonOutput::writeJson(routeId);
            p->value["atomId"] = tars::JsonOutput::writeJson(atomId);
            p->value["meetingId"] = tars::JsonOutput::writeJson(meetingId);
            p->value["priceNumber"] = tars::JsonOutput::writeJson(priceNumber);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(caller,pObj->value["caller"], true);
            tars::JsonInput::readJson(callee,pObj->value["callee"], true);
            tars::JsonInput::readJson(chargeAccount,pObj->value["chargeAccount"], true);
            tars::JsonInput::readJson(midCallUser,pObj->value["midCallUser"], true);
            tars::JsonInput::readJson(origSrcUser,pObj->value["origSrcUser"], true);
            tars::JsonInput::readJson(origDstUser,pObj->value["origDstUser"], true);
            tars::JsonInput::readJson(routeId,pObj->value["routeId"], true);
            tars::JsonInput::readJson(atomId,pObj->value["atomId"], true);
            tars::JsonInput::readJson(meetingId,pObj->value["meetingId"], true);
            tars::JsonInput::readJson(priceNumber,pObj->value["priceNumber"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(caller,"caller");
            _ds.display(callee,"callee");
            _ds.display(chargeAccount,"chargeAccount");
            _ds.display(midCallUser,"midCallUser");
            _ds.display(origSrcUser,"origSrcUser");
            _ds.display(origDstUser,"origDstUser");
            _ds.display(routeId,"routeId");
            _ds.display(atomId,"atomId");
            _ds.display(meetingId,"meetingId");
            _ds.display(priceNumber,"priceNumber");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(caller, true);
            _ds.displaySimple(callee, true);
            _ds.displaySimple(chargeAccount, true);
            _ds.displaySimple(midCallUser, true);
            _ds.displaySimple(origSrcUser, true);
            _ds.displaySimple(origDstUser, true);
            _ds.displaySimple(routeId, true);
            _ds.displaySimple(atomId, true);
            _ds.displaySimple(meetingId, true);
            _ds.displaySimple(priceNumber, false);
            return _os;
        }
    public:
        std::string caller;
        std::string callee;
        std::string chargeAccount;
        std::string midCallUser;
        std::string origSrcUser;
        std::string origDstUser;
        std::string routeId;
        std::string atomId;
        std::string meetingId;
        std::string priceNumber;
    };
    inline bool operator==(const OcsChargeInfo&l, const OcsChargeInfo&r)
    {
        return l.caller == r.caller && l.callee == r.callee && l.chargeAccount == r.chargeAccount && l.midCallUser == r.midCallUser && l.origSrcUser == r.origSrcUser && l.origDstUser == r.origDstUser && l.routeId == r.routeId && l.atomId == r.atomId && l.meetingId == r.meetingId && l.priceNumber == r.priceNumber;
    }
    inline bool operator!=(const OcsChargeInfo&l, const OcsChargeInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const OcsChargeInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,OcsChargeInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


    /* callback of async proxy for client */
    class SipChargePrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~SipChargePrxCallback(){}
        virtual void callback_getCallDuration(tars::Bool ret,  const std::string& atsOid)
        { throw std::runtime_error("callback_getCallDuration() override incorrect."); }
        virtual void callback_getCallDuration_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getCallDuration_exception() override incorrect."); }
        virtual void callback_getCallDuration(tars::Bool ret, std::string&&  atsOid)
        { callback_getCallDuration(ret, atsOid); }

        virtual void callback_getOcsChargeStatus(tars::Bool ret,  const std::string& atsOid, tars::Int32 iSessId, tars::Int32 iCCId)
        { throw std::runtime_error("callback_getOcsChargeStatus() override incorrect."); }
        virtual void callback_getOcsChargeStatus_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getOcsChargeStatus_exception() override incorrect."); }
        virtual void callback_getOcsChargeStatus(tars::Bool ret, std::string&&  atsOid, tars::Int32 iSessId, tars::Int32 iCCId)
        { callback_getOcsChargeStatus(ret, atsOid, iSessId, iCCId); }

        virtual void callback_getOcsConnectStatus(tars::Bool ret,  const std::string& atsOid, tars::Int32 sessId, tars::Int32 status, tars::Int32 statCode)
        { throw std::runtime_error("callback_getOcsConnectStatus() override incorrect."); }
        virtual void callback_getOcsConnectStatus_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getOcsConnectStatus_exception() override incorrect."); }
        virtual void callback_getOcsConnectStatus(tars::Bool ret, std::string&&  atsOid, tars::Int32 sessId, tars::Int32 status, tars::Int32 statCode)
        { callback_getOcsConnectStatus(ret, atsOid, sessId, status, statCode); }

        virtual void callback_stopOcsCharge(tars::Bool ret,  const std::string& atsOid)
        { throw std::runtime_error("callback_stopOcsCharge() override incorrect."); }
        virtual void callback_stopOcsCharge_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopOcsCharge_exception() override incorrect."); }
        virtual void callback_stopOcsCharge(tars::Bool ret, std::string&&  atsOid)
        { callback_stopOcsCharge(ret, atsOid); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipCharge_all[]=
            {
                "getCallDuration",
                "getOcsChargeStatus",
                "getOcsConnectStatus",
                "stopOcsCharge"
            };
            auto it = _msg_->response->status.find("TARS_FUNC");
            pair<string*, string*> r = equal_range(__SipCharge_all, __SipCharge_all+4, (it==_msg_->response->status.end())?_msg_->request.sFuncName:it->second);
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipCharge_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getCallDuration_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string atsOid;
                    _is.read(atsOid, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getCallDuration", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getCallDuration(_ret, std::move(atsOid));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsChargeStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string atsOid;
                    _is.read(atsOid, 4, true);
                    tars::Int32 iSessId;
                    _is.read(iSessId, 5, true);
                    tars::Int32 iCCId;
                    _is.read(iCCId, 6, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p_->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                            _p_->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getOcsChargeStatus", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getOcsChargeStatus(_ret, std::move(atsOid), iSessId, iCCId);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsConnectStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string atsOid;
                    _is.read(atsOid, 2, true);
                    tars::Int32 sessId;
                    _is.read(sessId, 3, true);
                    tars::Int32 status;
                    _is.read(status, 4, true);
                    tars::Int32 statCode;
                    _is.read(statCode, 5, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                            _p_->value["status"] = tars::JsonOutput::writeJson(status);
                            _p_->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "getOcsConnectStatus", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_getOcsConnectStatus(_ret, std::move(atsOid), sessId, status, statCode);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopOcsCharge_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    tars::Bool _ret = false;
                    _is.read(_ret, 0, true);

                    std::string atsOid;
                    _is.read(atsOid, 9, true);
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                            _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, "", getModuleName(), "stopOcsCharge", 0, _trace_param_, "");
                    }

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(_msg_->response->context);

                    callback_stopOcsCharge(_ret, std::move(atsOid));

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<SipChargePrxCallback> SipChargePrxCallbackPtr;

    //callback of promise async proxy for client
    class SipChargePrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~SipChargePrxCallbackPromise(){}
    public:
        struct PromisegetCallDuration: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string atsOid;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipChargePrxCallbackPromise::PromisegetCallDuration > PromisegetCallDurationPtr;

        SipChargePrxCallbackPromise(const tars::Promise< SipChargePrxCallbackPromise::PromisegetCallDurationPtr > &promise)
        : _promise_getCallDuration(promise)
        {}
        
        virtual void callback_getCallDuration(const SipChargePrxCallbackPromise::PromisegetCallDurationPtr &ptr)
        {
            _promise_getCallDuration.setValue(ptr);
        }
        virtual void callback_getCallDuration_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getCallDuration_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getCallDuration.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipChargePrxCallbackPromise::PromisegetCallDurationPtr > _promise_getCallDuration;

    public:
        struct PromisegetOcsChargeStatus: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string atsOid;
            tars::Int32 iSessId;
            tars::Int32 iCCId;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipChargePrxCallbackPromise::PromisegetOcsChargeStatus > PromisegetOcsChargeStatusPtr;

        SipChargePrxCallbackPromise(const tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr > &promise)
        : _promise_getOcsChargeStatus(promise)
        {}
        
        virtual void callback_getOcsChargeStatus(const SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr &ptr)
        {
            _promise_getOcsChargeStatus.setValue(ptr);
        }
        virtual void callback_getOcsChargeStatus_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getOcsChargeStatus_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getOcsChargeStatus.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr > _promise_getOcsChargeStatus;

    public:
        struct PromisegetOcsConnectStatus: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string atsOid;
            tars::Int32 sessId;
            tars::Int32 status;
            tars::Int32 statCode;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipChargePrxCallbackPromise::PromisegetOcsConnectStatus > PromisegetOcsConnectStatusPtr;

        SipChargePrxCallbackPromise(const tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr > &promise)
        : _promise_getOcsConnectStatus(promise)
        {}
        
        virtual void callback_getOcsConnectStatus(const SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr &ptr)
        {
            _promise_getOcsConnectStatus.setValue(ptr);
        }
        virtual void callback_getOcsConnectStatus_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getOcsConnectStatus_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getOcsConnectStatus.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr > _promise_getOcsConnectStatus;

    public:
        struct PromisestopOcsCharge: virtual public TC_HandleBase
        {
        public:
            tars::Bool _ret;
            std::string atsOid;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< SipChargePrxCallbackPromise::PromisestopOcsCharge > PromisestopOcsChargePtr;

        SipChargePrxCallbackPromise(const tars::Promise< SipChargePrxCallbackPromise::PromisestopOcsChargePtr > &promise)
        : _promise_stopOcsCharge(promise)
        {}
        
        virtual void callback_stopOcsCharge(const SipChargePrxCallbackPromise::PromisestopOcsChargePtr &ptr)
        {
            _promise_stopOcsCharge.setValue(ptr);
        }
        virtual void callback_stopOcsCharge_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopOcsCharge_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopOcsCharge.setException(tars::copyException(str, ret));
        }

    protected:
        tars::Promise< SipChargePrxCallbackPromise::PromisestopOcsChargePtr > _promise_stopOcsCharge;

    public:
        virtual int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipCharge_all[]=
            {
                "getCallDuration",
                "getOcsChargeStatus",
                "getOcsConnectStatus",
                "stopOcsCharge"
            };

            pair<string*, string*> r = equal_range(__SipCharge_all, __SipCharge_all+4, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipCharge_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getCallDuration_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipChargePrxCallbackPromise::PromisegetCallDurationPtr ptr (new SipChargePrxCallbackPromise::PromisegetCallDuration());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->atsOid, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getCallDuration_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getCallDuration_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getCallDuration(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsChargeStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr ptr (new SipChargePrxCallbackPromise::PromisegetOcsChargeStatus());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->atsOid, 4, true);
                        _is.read(ptr->iSessId, 5, true);
                        _is.read(ptr->iCCId, 6, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getOcsChargeStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getOcsChargeStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getOcsChargeStatus(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsConnectStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr ptr (new SipChargePrxCallbackPromise::PromisegetOcsConnectStatus());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->atsOid, 2, true);
                        _is.read(ptr->sessId, 3, true);
                        _is.read(ptr->status, 4, true);
                        _is.read(ptr->statCode, 5, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getOcsConnectStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getOcsConnectStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_getOcsConnectStatus(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopOcsCharge_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);

                    SipChargePrxCallbackPromise::PromisestopOcsChargePtr ptr (new SipChargePrxCallbackPromise::PromisestopOcsCharge());

                    try
                    {
                        ptr->_ret  = false;
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->atsOid, 9, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopOcsCharge_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopOcsCharge_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = _msg_->response->context;

                    callback_stopOcsCharge(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<SipChargePrxCallbackPromise> SipChargePrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class SipChargeCoroPrxCallback: public SipChargePrxCallback
    {
    public:
        virtual ~SipChargeCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr _msg_)
        {
            static ::std::string __SipCharge_all[]=
            {
                "getCallDuration",
                "getOcsChargeStatus",
                "getOcsConnectStatus",
                "stopOcsCharge"
            };

            pair<string*, string*> r = equal_range(__SipCharge_all, __SipCharge_all+4, string(_msg_->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __SipCharge_all)
            {
                case 0:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getCallDuration_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string atsOid;
                        _is.read(atsOid, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_getCallDuration(_ret, std::move(atsOid));

                    }
                    catch(std::exception &ex)
                    {
                        callback_getCallDuration_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getCallDuration_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsChargeStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string atsOid;
                        _is.read(atsOid, 4, true);
                        tars::Int32 iSessId;
                        _is.read(iSessId, 5, true);
                        tars::Int32 iCCId;
                        _is.read(iCCId, 6, true);
                        setResponseContext(_msg_->response->context);

                        callback_getOcsChargeStatus(_ret, std::move(atsOid), iSessId, iCCId);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getOcsChargeStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getOcsChargeStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getOcsConnectStatus_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string atsOid;
                        _is.read(atsOid, 2, true);
                        tars::Int32 sessId;
                        _is.read(sessId, 3, true);
                        tars::Int32 status;
                        _is.read(status, 4, true);
                        tars::Int32 statCode;
                        _is.read(statCode, 5, true);
                        setResponseContext(_msg_->response->context);

                        callback_getOcsConnectStatus(_ret, std::move(atsOid), sessId, status, statCode);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getOcsConnectStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getOcsConnectStatus_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (_msg_->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopOcsCharge_exception(_msg_->response->iRet);

                        return _msg_->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(_msg_->response->sBuffer);
                    try
                    {
                        tars::Bool _ret = false;
                        _is.read(_ret, 0, true);

                        std::string atsOid;
                        _is.read(atsOid, 9, true);
                        setResponseContext(_msg_->response->context);

                        callback_stopOcsCharge(_ret, std::move(atsOid));

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopOcsCharge_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopOcsCharge_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<SipChargeCoroPrxCallback> SipChargeCoroPrxCallbackPtr;

    /* proxy for client */
    class SipChargeProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Bool getCallDuration(const std::string & sipGatewayId,const std::string & callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,std::string &atsOid,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            _os.write(atsOid, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                    _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getCallDuration", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getCallDuration", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(atsOid, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getCallDuration", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getCallDuration(SipChargePrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                    _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getCallDuration", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getCallDuration", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipChargePrxCallbackPromise::PromisegetCallDurationPtr > promise_async_getCallDuration(const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,const map<string, string>& context)
        {
            tars::Promise< SipChargePrxCallbackPromise::PromisegetCallDurationPtr > promise;
            SipChargePrxCallbackPromisePtr callback (new SipChargePrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getCallDuration", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getCallDuration(SipChargeCoroPrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getCallDuration", _os, context, _mStatus, callback, true);
        }

        tars::Bool getOcsChargeStatus(const std::string & sipGatewayId,const std::string & callId,const VoipApp::OcsChargeInfo & chargeInfo,std::string &atsOid,tars::Int32 &iSessId,tars::Int32 &iCCId,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(chargeInfo, 3);
            _os.write(atsOid, 4);
            _os.write(iSessId, 5);
            _os.write(iCCId, 6);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["chargeInfo"] = tars::JsonOutput::writeJson(chargeInfo);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getOcsChargeStatus", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getOcsChargeStatus", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(atsOid, 4, true);
            _is.read(iSessId, 5, true);
            _is.read(iCCId, 6, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _p_->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                    _p_->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getOcsChargeStatus", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getOcsChargeStatus(SipChargePrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,const VoipApp::OcsChargeInfo &chargeInfo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(chargeInfo, 3);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["chargeInfo"] = tars::JsonOutput::writeJson(chargeInfo);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getOcsChargeStatus", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getOcsChargeStatus", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr > promise_async_getOcsChargeStatus(const std::string &sipGatewayId,const std::string &callId,const VoipApp::OcsChargeInfo &chargeInfo,const map<string, string>& context)
        {
            tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsChargeStatusPtr > promise;
            SipChargePrxCallbackPromisePtr callback (new SipChargePrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(chargeInfo, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getOcsChargeStatus", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getOcsChargeStatus(SipChargeCoroPrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,const VoipApp::OcsChargeInfo &chargeInfo,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(chargeInfo, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getOcsChargeStatus", _os, context, _mStatus, callback, true);
        }

        tars::Bool getOcsConnectStatus(const std::string & sipGatewayId,std::string &atsOid,tars::Int32 &sessId,tars::Int32 &status,tars::Int32 &statCode,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(atsOid, 2);
            _os.write(sessId, 3);
            _os.write(status, 4);
            _os.write(statCode, 5);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getOcsConnectStatus", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"getOcsConnectStatus", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(atsOid, 2, true);
            _is.read(sessId, 3, true);
            _is.read(status, 4, true);
            _is.read(statCode, 5, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["status"] = tars::JsonOutput::writeJson(status);
                    _p_->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "getOcsConnectStatus", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_getOcsConnectStatus(SipChargePrxCallbackPtr callback,const std::string &sipGatewayId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "getOcsConnectStatus", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"getOcsConnectStatus", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr > promise_async_getOcsConnectStatus(const std::string &sipGatewayId,const map<string, string>& context)
        {
            tars::Promise< SipChargePrxCallbackPromise::PromisegetOcsConnectStatusPtr > promise;
            SipChargePrxCallbackPromisePtr callback (new SipChargePrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getOcsConnectStatus", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getOcsConnectStatus(SipChargeCoroPrxCallbackPtr callback,const std::string &sipGatewayId,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getOcsConnectStatus", _os, context, _mStatus, callback, true);
        }

        tars::Bool stopOcsCharge(const std::string & sipGatewayId,const std::string & callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,const map<std::string, std::string> & params,std::string &atsOid,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            _os.write(ringTime, 6);
            _os.write(finishType, 7);
            _os.write(params, 8);
            _os.write(atsOid, 9);
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                    _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                    _p_->value["ringTime"] = tars::JsonOutput::writeJson(ringTime);
                    _p_->value["finishType"] = tars::JsonOutput::writeJson(finishType);
                    _p_->value["params"] = tars::JsonOutput::writeJson(params);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "stopOcsCharge", 0, _trace_param_, "");
            }

            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"stopOcsCharge", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Bool _ret = false;
            _is.read(_ret, 0, true);
            _is.read(atsOid, 9, true);
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CR, _is.size());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CR), TRACE_ANNOTATION_CR, tars_moduleName(), tars_name(), "stopOcsCharge", 0, _trace_param_, "");
            }

            return _ret;
        }

        void async_stopOcsCharge(SipChargePrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,const map<std::string, std::string> &params,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            _os.write(ringTime, 6);
            _os.write(finishType, 7);
            _os.write(params, 8);
            std::map<string, string> _mStatus;
            ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
            if (_pSptd_ && _pSptd_->_traceCall)
            {
                _pSptd_->newSpan();
                string _trace_param_;
                int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_CS, _os.getLength());
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                    _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                    _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                    _p_->value["ringTime"] = tars::JsonOutput::writeJson(ringTime);
                    _p_->value["finishType"] = tars::JsonOutput::writeJson(finishType);
                    _p_->value["params"] = tars::JsonOutput::writeJson(params);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_CS), TRACE_ANNOTATION_CS, tars_moduleName(), tars_name(), "stopOcsCharge", 0, _trace_param_, "");
            }
            tars_invoke_async(tars::TARSNORMAL,"stopOcsCharge", _os, context, _mStatus, callback);
        }
        
        tars::Future< SipChargePrxCallbackPromise::PromisestopOcsChargePtr > promise_async_stopOcsCharge(const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,const map<std::string, std::string> &params,const map<string, string>& context)
        {
            tars::Promise< SipChargePrxCallbackPromise::PromisestopOcsChargePtr > promise;
            SipChargePrxCallbackPromisePtr callback (new SipChargePrxCallbackPromise(promise));

            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            _os.write(ringTime, 6);
            _os.write(finishType, 7);
            _os.write(params, 8);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopOcsCharge", _os, context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopOcsCharge(SipChargeCoroPrxCallbackPtr callback,const std::string &sipGatewayId,const std::string &callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,const map<std::string, std::string> &params,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(sipGatewayId, 1);
            _os.write(callId, 2);
            _os.write(sessId, 3);
            _os.write(ccId, 4);
            _os.write(usedTime, 5);
            _os.write(ringTime, 6);
            _os.write(finishType, 7);
            _os.write(params, 8);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopOcsCharge", _os, context, _mStatus, callback, true);
        }

        SipChargeProxy* tars_hash(size_t key)
        {
            return (SipChargeProxy*)ServantProxy::tars_hash(key);
        }

        SipChargeProxy* tars_consistent_hash(size_t key)
        {
            return (SipChargeProxy*)ServantProxy::tars_consistent_hash(key);
        }

        SipChargeProxy* tars_open_trace(bool traceParam = false)
        {
            return (SipChargeProxy*)ServantProxy::tars_open_trace(traceParam);
        }

        SipChargeProxy* tars_set_timeout(int msecond)
        {
            return (SipChargeProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "SipChargeProxy"; }
    };
    typedef tars::TC_AutoPtr<SipChargeProxy> SipChargePrx;

    /* servant for server */
    class SipCharge : public tars::Servant
    {
    public:
        virtual ~SipCharge(){}
        virtual tars::Bool getCallDuration(const std::string & sipGatewayId,const std::string & callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,std::string &atsOid,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getCallDuration(std::string && sipGatewayId,std::string && callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,std::string &atsOid,tars::TarsCurrentPtr _current_) 
        { return getCallDuration(sipGatewayId, callId, sessId, ccId, usedTime, atsOid, _current_); }
        static void async_response_getCallDuration(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &atsOid)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("atsOid", atsOid);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getCallDuration", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getCallDuration(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getCallDuration", _os, _context);
            }
        }

        virtual tars::Bool getOcsChargeStatus(const std::string & sipGatewayId,const std::string & callId,const VoipApp::OcsChargeInfo & chargeInfo,std::string &atsOid,tars::Int32 &iSessId,tars::Int32 &iCCId,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getOcsChargeStatus(std::string && sipGatewayId,std::string && callId,VoipApp::OcsChargeInfo && chargeInfo,std::string &atsOid,tars::Int32 &iSessId,tars::Int32 &iCCId,tars::TarsCurrentPtr _current_) 
        { return getOcsChargeStatus(sipGatewayId, callId, chargeInfo, atsOid, iSessId, iCCId, _current_); }
        static void async_response_getOcsChargeStatus(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, tars::Int32 iSessId, tars::Int32 iCCId)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("atsOid", atsOid);
                _tarsAttr_.put("iSessId", iSessId);
                _tarsAttr_.put("iCCId", iCCId);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                _p->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                _p->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 4);

                _os.write(iSessId, 5);

                _os.write(iCCId, 6);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _p_->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                    _p_->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getOcsChargeStatus", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getOcsChargeStatus(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, tars::Int32 iSessId, tars::Int32 iCCId, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 4);

                _os.write(iSessId, 5);

                _os.write(iCCId, 6);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getOcsChargeStatus", _os, _context);
            }
        }

        virtual tars::Bool getOcsConnectStatus(const std::string & sipGatewayId,std::string &atsOid,tars::Int32 &sessId,tars::Int32 &status,tars::Int32 &statCode,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool getOcsConnectStatus(std::string && sipGatewayId,std::string &atsOid,tars::Int32 &sessId,tars::Int32 &status,tars::Int32 &statCode,tars::TarsCurrentPtr _current_) 
        { return getOcsConnectStatus(sipGatewayId, atsOid, sessId, status, statCode, _current_); }
        static void async_response_getOcsConnectStatus(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, tars::Int32 sessId, tars::Int32 status, tars::Int32 statCode)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("atsOid", atsOid);
                _tarsAttr_.put("sessId", sessId);
                _tarsAttr_.put("status", status);
                _tarsAttr_.put("statCode", statCode);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                _p->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                _p->value["status"] = tars::JsonOutput::writeJson(status);
                _p->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 2);

                _os.write(sessId, 3);

                _os.write(status, 4);

                _os.write(statCode, 5);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                    _p_->value["status"] = tars::JsonOutput::writeJson(status);
                    _p_->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "getOcsConnectStatus", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_getOcsConnectStatus(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, tars::Int32 sessId, tars::Int32 status, tars::Int32 statCode, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 2);

                _os.write(sessId, 3);

                _os.write(status, 4);

                _os.write(statCode, 5);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"getOcsConnectStatus", _os, _context);
            }
        }

        virtual tars::Bool stopOcsCharge(const std::string & sipGatewayId,const std::string & callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,const map<std::string, std::string> & params,std::string &atsOid,tars::TarsCurrentPtr _current_) = 0;
        virtual tars::Bool stopOcsCharge(std::string && sipGatewayId,std::string && callId,tars::Int32 sessId,tars::Int32 ccId,tars::Int32 usedTime,tars::Int32 ringTime,tars::Int32 finishType,map<std::string, std::string> && params,std::string &atsOid,tars::TarsCurrentPtr _current_) 
        { return stopOcsCharge(sipGatewayId, callId, sessId, ccId, usedTime, ringTime, finishType, params, atsOid, _current_); }
        static void async_response_stopOcsCharge(tars::TarsCurrentPtr _current_, tars::Bool _ret, const std::string &atsOid)
        {
            size_t _rsp_len_ = 0;
            if (_current_->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                _tarsAttr_.setVersion(_current_->getRequestVersion());
                _tarsAttr_.put("", _ret);
                _tarsAttr_.put("tars_ret", _ret);
                _tarsAttr_.put("atsOid", atsOid);

                vector<char> sTupResponseBuffer;
                _tarsAttr_.encode(sTupResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _tarsAttr_);
                _rsp_len_ = sTupResponseBuffer.size();
            }
            else if (_current_->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                _current_->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
                _rsp_len_ = sJsonResponseBuffer.size();
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 9);

                _rsp_len_ = _os.getLength();
                _current_->sendResponse(tars::TARSSERVERSUCCESS, _os);
            }
            if (_current_->isTraced())
            {
                string _trace_param_;
                int _trace_param_flag_ = ServantProxyThreadData::needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _current_->getTraceKey(), _rsp_len_);
                if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                {
                    tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                    _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                    _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                    _trace_param_ = tars::TC_Json::writeValue(_p_);
                }
                else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                {
                    _trace_param_ = "{\"trace_param_over_max_len\":true}";
                }
                if(_current_->getServantHandle())
                {
                    TARS_TRACE(_current_->getTraceKey(), TRACE_ANNOTATION_SS, "", _current_->getModuleName(), "stopOcsCharge", 0, _trace_param_, "");
                }
            }

        }
        static void async_response_push_stopOcsCharge(tars::CurrentPtr _current_, tars::Bool _ret, const std::string &atsOid, const map<string, string> &_context = tars::Current::TARS_STATUS())
        {
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(atsOid, 9);

                _current_->sendPushResponse( tars::TARSSERVERSUCCESS ,"stopOcsCharge", _os, _context);
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __VoipApp__SipCharge_all[]=
            {
                "getCallDuration",
                "getOcsChargeStatus",
                "getOcsConnectStatus",
                "stopOcsCharge"
            };

            pair<string*, string*> r = equal_range(__VoipApp__SipCharge_all, __VoipApp__SipCharge_all+4, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __VoipApp__SipCharge_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sipGatewayId;
                    std::string callId;
                    tars::Int32 sessId;
                    tars::Int32 ccId;
                    tars::Int32 usedTime;
                    std::string atsOid;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sipGatewayId", sipGatewayId);
                        _tarsAttr_.get("callId", callId);
                        _tarsAttr_.get("sessId", sessId);
                        _tarsAttr_.get("ccId", ccId);
                        _tarsAttr_.get("usedTime", usedTime);
                        _tarsAttr_.getByDefault("atsOid", atsOid, atsOid);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sipGatewayId, _jsonPtr->value["sipGatewayId"], true);
                        tars::JsonInput::readJson(callId, _jsonPtr->value["callId"], true);
                        tars::JsonInput::readJson(sessId, _jsonPtr->value["sessId"], true);
                        tars::JsonInput::readJson(ccId, _jsonPtr->value["ccId"], true);
                        tars::JsonInput::readJson(usedTime, _jsonPtr->value["usedTime"], true);
                        tars::JsonInput::readJson(atsOid, _jsonPtr->value["atsOid"], false);
                    }
                    else
                    {
                        _is.read(sipGatewayId, 1, true);
                        _is.read(callId, 2, true);
                        _is.read(sessId, 3, true);
                        _is.read(ccId, 4, true);
                        _is.read(usedTime, 5, true);
                        _is.read(atsOid, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                            _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                            _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                            _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                            _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getCallDuration", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getCallDuration(std::move(sipGatewayId),std::move(callId),sessId,ccId,usedTime,atsOid, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("atsOid", atsOid);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(atsOid, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getCallDuration", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sipGatewayId;
                    std::string callId;
                    VoipApp::OcsChargeInfo chargeInfo;
                    std::string atsOid;
                    tars::Int32 iSessId;
                    tars::Int32 iCCId;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sipGatewayId", sipGatewayId);
                        _tarsAttr_.get("callId", callId);
                        _tarsAttr_.get("chargeInfo", chargeInfo);
                        _tarsAttr_.getByDefault("atsOid", atsOid, atsOid);
                        _tarsAttr_.getByDefault("iSessId", iSessId, iSessId);
                        _tarsAttr_.getByDefault("iCCId", iCCId, iCCId);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sipGatewayId, _jsonPtr->value["sipGatewayId"], true);
                        tars::JsonInput::readJson(callId, _jsonPtr->value["callId"], true);
                        tars::JsonInput::readJson(chargeInfo, _jsonPtr->value["chargeInfo"], true);
                        tars::JsonInput::readJson(atsOid, _jsonPtr->value["atsOid"], false);
                        tars::JsonInput::readJson(iSessId, _jsonPtr->value["iSessId"], false);
                        tars::JsonInput::readJson(iCCId, _jsonPtr->value["iCCId"], false);
                    }
                    else
                    {
                        _is.read(sipGatewayId, 1, true);
                        _is.read(callId, 2, true);
                        _is.read(chargeInfo, 3, true);
                        _is.read(atsOid, 4, false);
                        _is.read(iSessId, 5, false);
                        _is.read(iCCId, 6, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                            _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                            _p_->value["chargeInfo"] = tars::JsonOutput::writeJson(chargeInfo);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getOcsChargeStatus", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getOcsChargeStatus(std::move(sipGatewayId),std::move(callId),std::move(chargeInfo),atsOid,iSessId,iCCId, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("atsOid", atsOid);
                            _tarsAttr_.put("iSessId", iSessId);
                            _tarsAttr_.put("iCCId", iCCId);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                            _p->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(atsOid, 4);
                            _os.write(iSessId, 5);
                            _os.write(iCCId, 6);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                                _p_->value["iSessId"] = tars::JsonOutput::writeJson(iSessId);
                                _p_->value["iCCId"] = tars::JsonOutput::writeJson(iCCId);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getOcsChargeStatus", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sipGatewayId;
                    std::string atsOid;
                    tars::Int32 sessId;
                    tars::Int32 status;
                    tars::Int32 statCode;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sipGatewayId", sipGatewayId);
                        _tarsAttr_.getByDefault("atsOid", atsOid, atsOid);
                        _tarsAttr_.getByDefault("sessId", sessId, sessId);
                        _tarsAttr_.getByDefault("status", status, status);
                        _tarsAttr_.getByDefault("statCode", statCode, statCode);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sipGatewayId, _jsonPtr->value["sipGatewayId"], true);
                        tars::JsonInput::readJson(atsOid, _jsonPtr->value["atsOid"], false);
                        tars::JsonInput::readJson(sessId, _jsonPtr->value["sessId"], false);
                        tars::JsonInput::readJson(status, _jsonPtr->value["status"], false);
                        tars::JsonInput::readJson(statCode, _jsonPtr->value["statCode"], false);
                    }
                    else
                    {
                        _is.read(sipGatewayId, 1, true);
                        _is.read(atsOid, 2, false);
                        _is.read(sessId, 3, false);
                        _is.read(status, 4, false);
                        _is.read(statCode, 5, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "getOcsConnectStatus", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = getOcsConnectStatus(std::move(sipGatewayId),atsOid,sessId,status,statCode, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("atsOid", atsOid);
                            _tarsAttr_.put("sessId", sessId);
                            _tarsAttr_.put("status", status);
                            _tarsAttr_.put("statCode", statCode);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                            _p->value["status"] = tars::JsonOutput::writeJson(status);
                            _p->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(atsOid, 2);
                            _os.write(sessId, 3);
                            _os.write(status, 4);
                            _os.write(statCode, 5);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                                _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                                _p_->value["status"] = tars::JsonOutput::writeJson(status);
                                _p_->value["statCode"] = tars::JsonOutput::writeJson(statCode);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "getOcsConnectStatus", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sipGatewayId;
                    std::string callId;
                    tars::Int32 sessId;
                    tars::Int32 ccId;
                    tars::Int32 usedTime;
                    tars::Int32 ringTime;
                    tars::Int32 finishType;
                    map<std::string, std::string> params;
                    std::string atsOid;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                        _tarsAttr_.setVersion(_current->getRequestVersion());
                        _tarsAttr_.decode(_current->getRequestBuffer());
                        _tarsAttr_.get("sipGatewayId", sipGatewayId);
                        _tarsAttr_.get("callId", callId);
                        _tarsAttr_.get("sessId", sessId);
                        _tarsAttr_.get("ccId", ccId);
                        _tarsAttr_.get("usedTime", usedTime);
                        _tarsAttr_.get("ringTime", ringTime);
                        _tarsAttr_.get("finishType", finishType);
                        _tarsAttr_.get("params", params);
                        _tarsAttr_.getByDefault("atsOid", atsOid, atsOid);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(sipGatewayId, _jsonPtr->value["sipGatewayId"], true);
                        tars::JsonInput::readJson(callId, _jsonPtr->value["callId"], true);
                        tars::JsonInput::readJson(sessId, _jsonPtr->value["sessId"], true);
                        tars::JsonInput::readJson(ccId, _jsonPtr->value["ccId"], true);
                        tars::JsonInput::readJson(usedTime, _jsonPtr->value["usedTime"], true);
                        tars::JsonInput::readJson(ringTime, _jsonPtr->value["ringTime"], true);
                        tars::JsonInput::readJson(finishType, _jsonPtr->value["finishType"], true);
                        tars::JsonInput::readJson(params, _jsonPtr->value["params"], true);
                        tars::JsonInput::readJson(atsOid, _jsonPtr->value["atsOid"], false);
                    }
                    else
                    {
                        _is.read(sipGatewayId, 1, true);
                        _is.read(callId, 2, true);
                        _is.read(sessId, 3, true);
                        _is.read(ccId, 4, true);
                        _is.read(usedTime, 5, true);
                        _is.read(ringTime, 6, true);
                        _is.read(finishType, 7, true);
                        _is.read(params, 8, true);
                        _is.read(atsOid, 9, false);
                    }
                    ServantProxyThreadData *_pSptd_ = ServantProxyThreadData::getData();
                    if (_pSptd_ && _pSptd_->_traceCall)
                    {
                        string _trace_param_;
                        int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SR, _is.size());
                        if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                        {
                            tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                            _p_->value["sipGatewayId"] = tars::JsonOutput::writeJson(sipGatewayId);
                            _p_->value["callId"] = tars::JsonOutput::writeJson(callId);
                            _p_->value["sessId"] = tars::JsonOutput::writeJson(sessId);
                            _p_->value["ccId"] = tars::JsonOutput::writeJson(ccId);
                            _p_->value["usedTime"] = tars::JsonOutput::writeJson(usedTime);
                            _p_->value["ringTime"] = tars::JsonOutput::writeJson(ringTime);
                            _p_->value["finishType"] = tars::JsonOutput::writeJson(finishType);
                            _p_->value["params"] = tars::JsonOutput::writeJson(params);
                            _trace_param_ = tars::TC_Json::writeValue(_p_);
                        }
                        else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                        {
                            _trace_param_ = "{\"trace_param_over_max_len\":true}";
                        }
                        TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SR), TRACE_ANNOTATION_SR, "", getModuleName(), "stopOcsCharge", 0, _trace_param_, "");
                    }

                    tars::Bool _ret = stopOcsCharge(std::move(sipGatewayId),std::move(callId),sessId,ccId,usedTime,ringTime,finishType,std::move(params),atsOid, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  _tarsAttr_;
                            _tarsAttr_.setVersion(_current->getRequestVersion());
                            _tarsAttr_.put("", _ret);
                            _tarsAttr_.put("tars_ret", _ret);
                            _tarsAttr_.put("atsOid", atsOid);
                            _tarsAttr_.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(atsOid, 9);
                            _os.swap(_sResponseBuffer);
                        }
                        if (_pSptd_ && _pSptd_->_traceCall)
                        {
                            string _trace_param_;
                            int _trace_param_flag_ = _pSptd_->needTraceParam(ServantProxyThreadData::TraceContext::EST_SS, _sResponseBuffer.size());
                            if (ServantProxyThreadData::TraceContext::ENP_NORMAL == _trace_param_flag_)
                            {
                                tars::JsonValueObjPtr _p_ = new tars::JsonValueObj();
                                _p_->value[""] = tars::JsonOutput::writeJson(_ret);
                                _p_->value["atsOid"] = tars::JsonOutput::writeJson(atsOid);
                                _trace_param_ = tars::TC_Json::writeValue(_p_);
                            }
                            else if(ServantProxyThreadData::TraceContext::ENP_OVERMAXLEN == _trace_param_flag_)
                            {
                                _trace_param_ = "{\"trace_param_over_max_len\":true}";
                            }
                            TARS_TRACE(_pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS), TRACE_ANNOTATION_SS, "", getModuleName(), "stopOcsCharge", 0, _trace_param_, "");
                        }

                    }
                    else if(_pSptd_ && _pSptd_->_traceCall)
                    {
                        _current->setTrace(_pSptd_->_traceCall, _pSptd_->getTraceKey(ServantProxyThreadData::TraceContext::EST_SS));
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
